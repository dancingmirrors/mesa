From 279a3e1343976f4e005e8512ff99bbf8e47eafe1 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 4 Oct 2024 09:35:34 -0400
Subject: [PATCH 01/27] va/vl: fix zink init

very stupid oversights
---
 src/gallium/auxiliary/vl/vl_winsys_kopper.c | 2 +-
 src/gallium/frontends/va/meson.build        | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gallium/auxiliary/vl/vl_winsys_kopper.c b/src/gallium/auxiliary/vl/vl_winsys_kopper.c
index 5feb03ef5a6c4..c5bcfae031c1c 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_kopper.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_kopper.c
@@ -210,7 +210,7 @@ vl_kopper_screen_create_x11(Display *display, int screen)
       success = pipe_loader_vk_probe_dri(&scrn->base.dev);
 
    if (success)
-      pipe_loader_create_screen_vk(scrn->base.dev, false, false);
+      scrn->base.pscreen = pipe_loader_create_screen_vk(scrn->base.dev, false, false);
    if (!scrn->base.pscreen)
       goto error;
 
diff --git a/src/gallium/frontends/va/meson.build b/src/gallium/frontends/va/meson.build
index dffc8fbd3d48b..71b400b8e5b28 100644
--- a/src/gallium/frontends/va/meson.build
+++ b/src/gallium/frontends/va/meson.build
@@ -21,6 +21,6 @@ libva_st = static_library(
   include_directories : [inc_include, inc_src, inc_gallium, inc_gallium_aux],
   dependencies : [
     dep_va_headers, dep_x11_xcb, dep_xcb, dep_xcb_dri3,
-    dep_libdrm, idep_mesautil,
+    dep_libdrm, idep_mesautil, driver_zink,
   ],
 )
-- 
GitLab


From c79b32eac5bdf738cda7ae2da7abf59c44c39668 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 16 May 2024 10:37:38 -0400
Subject: [PATCH 02/27] zink: explicitly link with vtn

---
 src/gallium/drivers/zink/meson.build | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/meson.build b/src/gallium/drivers/zink/meson.build
index 97adf9ddc5aef..7727f396ff10a 100644
--- a/src/gallium/drivers/zink/meson.build
+++ b/src/gallium/drivers/zink/meson.build
@@ -93,7 +93,7 @@ libzink = static_library(
   include_directories : [inc_include, inc_src, inc_gallium, inc_gallium_aux, inc_vulkan_util, inc_zink_vk],
   link_args : [ld_args_build_id],
   dependencies: [
-    idep_nir_headers, idep_mesautil, idep_vulkan_util_headers,
+    idep_nir_headers, idep_mesautil, idep_vulkan_util_headers, idep_vtn,
     idep_vulkan_wsi_defines, idep_vulkan_util, dep_libdrm, vulkan_wsi_deps
   ],
   c_args: zink_c_args,
-- 
GitLab


From 6190face06921df3ff8887a8e3ffe36387c8c632 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 5 Sep 2025 11:44:42 -0400
Subject: [PATCH 03/27] zink: handle full-surface non-rt clears

---
 src/gallium/drivers/zink/zink_clear.c | 28 +++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_clear.c b/src/gallium/drivers/zink/zink_clear.c
index ed05d1d36acfa..6968d0263ece5 100644
--- a/src/gallium/drivers/zink/zink_clear.c
+++ b/src/gallium/drivers/zink/zink_clear.c
@@ -562,12 +562,32 @@ zink_clear_buffer(struct pipe_context *pctx,
 
 void
 zink_clear_render_target(struct pipe_context *pctx, struct pipe_surface *dst,
-                         const union pipe_color_union *color, unsigned dstx,
+                         const union pipe_color_union *pcolor, unsigned dstx,
                          unsigned dsty, unsigned width, unsigned height,
                          bool render_condition_enabled)
 {
    struct zink_context *ctx = zink_context(pctx);
-   struct pipe_resource *pres = dst->texture;
+   struct zink_resource *res = zink_resource(dst->texture);
+   if (width == 0 || height == 0)
+      return;
+   if (!res->obj->render_target) {
+      /* should only be hit by video */
+      if (dst->texture->bind & PIPE_BIND_SHADER_IMAGE) {
+         struct zink_screen *screen = zink_screen(pctx->screen);
+         /* this should always be a full clear */
+         assert(!dstx && !dsty);
+         VkClearColorValue color;
+         color.uint32[0] = pcolor->ui[0];
+         color.uint32[1] = pcolor->ui[1];
+         color.uint32[2] = pcolor->ui[2];
+         color.uint32[3] = pcolor->ui[3];
+         VkImageLayout layout = screen->driver_workarounds.general_layout ? VK_IMAGE_LAYOUT_GENERAL : VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+         VkImageSubresourceRange range = {res->aspect, dst->level, 1, dst->first_layer, dst->last_layer - dst->first_layer + 1};
+         zink_screen(ctx->base.screen)->image_barrier(ctx, res, layout, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT);
+         VKCTX(CmdClearColorImage)(ctx->bs->cmdbuf, res->obj->image, res->layout, &color, 1, &range);
+      }
+      return;
+   }
    bool render_condition_active = ctx->render_condition_active;
    if (!render_condition_enabled && render_condition_active) {
       zink_stop_conditional_render(ctx);
@@ -576,9 +596,9 @@ zink_clear_render_target(struct pipe_context *pctx, struct pipe_surface *dst,
    util_blitter_save_framebuffer(ctx->blitter, &ctx->fb_state);
    set_clear_fb(pctx, dst, NULL);
    struct pipe_scissor_state scissor = {dstx, dsty, dstx + width, dsty + height};
-   zink_blit_barriers(ctx, NULL, zink_resource(pres), false);
+   zink_blit_barriers(ctx, NULL, res, false);
    ctx->blitting = true;
-   pctx->clear(pctx, PIPE_CLEAR_COLOR0, &scissor, color, 0, 0);
+   pctx->clear(pctx, PIPE_CLEAR_COLOR0, &scissor, pcolor, 0, 0);
    util_blitter_restore_fb_state(ctx->blitter);
    ctx->blitting = false;
    if (!render_condition_enabled && render_condition_active)
-- 
GitLab


From 72199be917509cc34086b03ee2e4c3aeafecba9a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 10 Jul 2024 11:25:46 -0400
Subject: [PATCH 04/27] zink: clamp PIPE_BIND_SHARED + no modifiers -> LINEAR

this is not a valid combo
---
 src/gallium/drivers/zink/zink_resource.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 8b09f8dd68ab4..cc8f9c9f4db0a 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -793,7 +793,7 @@ init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
 
    if (screen->info.have_EXT_image_drm_format_modifier && modifiers_count)
       ici->tiling = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
-   else if (bind & (PIPE_BIND_LINEAR | ZINK_BIND_DMABUF))
+   else if (bind & (PIPE_BIND_LINEAR | ZINK_BIND_DMABUF) || (!modifiers_count && bind & PIPE_BIND_SHARED))
       ici->tiling = VK_IMAGE_TILING_LINEAR;
    else
       ici->tiling = VK_IMAGE_TILING_OPTIMAL;
-- 
GitLab


From 5d1c84111f502b7d539d920b29dc4bd157b5c2fa Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 24 Nov 2021 13:29:48 +1000
Subject: [PATCH 05/27] zink/video: add extensions for video

---
 src/gallium/drivers/zink/zink_device_info.py | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/zink/zink_device_info.py b/src/gallium/drivers/zink/zink_device_info.py
index fd768b3a623e7..94f4cf48cfd62 100644
--- a/src/gallium/drivers/zink/zink_device_info.py
+++ b/src/gallium/drivers/zink/zink_device_info.py
@@ -336,6 +336,9 @@ EXTENSIONS = [
     Extension("VK_KHR_shader_float_controls",
               alias="float_controls"),
     Extension("VK_KHR_format_feature_flags2"),
+    Extension("VK_KHR_video_queue"),
+    Extension("VK_KHR_video_decode_queue"),
+    Extension("VK_KHR_video_decode_h264"),
 ]
 
 # constructor: Versions(device_version(major, minor, patch), struct_version(major, minor))
-- 
GitLab


From d7dc6080ddf233f6dd61a172010307c2c6f219fe Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 24 Nov 2021 13:31:14 +1000
Subject: [PATCH 06/27] zink: add initial support for finding video queues

---
 src/gallium/drivers/zink/zink_screen.c | 28 +++++++++++++++++---------
 src/gallium/drivers/zink/zink_types.h  |  2 ++
 2 files changed, 21 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index 02bf0ac72355b..02207fd525eb1 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -1734,20 +1734,28 @@ update_queue_props(struct zink_screen *screen)
 
    bool found_gfx = false;
    uint32_t sparse_only = UINT32_MAX;
+   uint32_t video_only = UINT32_MAX;
    screen->sparse_queue = UINT32_MAX;
+   screen->video_decode_queue = UINT32_MAX;
    for (uint32_t i = 0; i < num_queues; i++) {
       if (props[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
          if (found_gfx)
             continue;
          screen->sparse_queue = screen->gfx_queue = i;
+         screen->video_decode_queue = screen->gfx_queue = i;
          screen->max_queues = props[i].queueCount;
          screen->timestamp_valid_bits = props[i].timestampValidBits;
          found_gfx = true;
-      } else if (props[i].queueFlags & VK_QUEUE_SPARSE_BINDING_BIT)
+      } else if (props[i].queueFlags & VK_QUEUE_SPARSE_BINDING_BIT) {
          sparse_only = i;
+      } else if (props[i].queueFlags & VK_QUEUE_VIDEO_DECODE_BIT_KHR) {
+         video_only = i;
+      }
    }
    if (sparse_only != UINT32_MAX)
       screen->sparse_queue = sparse_only;
+   if (video_only != UINT32_MAX)
+      screen->video_decode_queue = video_only;
    free(props);
 }
 
@@ -1760,6 +1768,10 @@ init_queue(struct zink_screen *screen)
       VKSCR(GetDeviceQueue)(screen->dev, screen->sparse_queue, 0, &screen->queue_sparse);
    else
       screen->queue_sparse = screen->queue;
+   if (screen->video_decode_queue != screen->gfx_queue)
+      VKSCR(GetDeviceQueue)(screen->dev, screen->video_decode_queue, 0, &screen->queue_video_decode);
+   else
+      screen->queue_video_decode = screen->queue;
 }
 
 static void
@@ -2689,22 +2701,20 @@ get_device(struct zink_screen *screen, VkDeviceCreateInfo *dci)
 static VkDevice
 zink_create_logical_device(struct zink_screen *screen)
 {
-   VkDeviceQueueCreateInfo qci[2] = {0};
-   uint32_t queues[3] = {
-      screen->gfx_queue,
-      screen->sparse_queue,
-   };
+   VkDeviceQueueCreateInfo qci[3] = {0};
    float dummy = 0.0f;
    for (unsigned i = 0; i < ARRAY_SIZE(qci); i++) {
       qci[i].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
-      qci[i].queueFamilyIndex = queues[i];
       qci[i].queueCount = 1;
       qci[i].pQueuePriorities = &dummy;
    }
 
-   unsigned num_queues = 1;
+   unsigned num_queues = 0;
+   qci[num_queues++].queueFamilyIndex = screen->gfx_queue;
    if (screen->sparse_queue != screen->gfx_queue)
-      num_queues++;
+      qci[num_queues++].queueFamilyIndex = screen->sparse_queue;
+   if (screen->video_decode_queue != screen->gfx_queue)
+      qci[num_queues++].queueFamilyIndex = screen->video_decode_queue;
 
    VkDeviceCreateInfo dci = {0};
    dci.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index fc073b8744764..bc76a7e3c8ac0 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -1448,12 +1448,14 @@ struct zink_screen {
    bool can_hic_shader_read;
 
    uint32_t gfx_queue;
+   uint32_t video_decode_queue;
    uint32_t sparse_queue;
    uint32_t max_queues;
    uint32_t timestamp_valid_bits;
    VkDevice dev;
    VkQueue queue; //gfx+compute
    VkQueue queue_sparse;
+   VkQueue queue_video_decode; //video decode
    simple_mtx_t queue_lock;
    VkDebugUtilsMessengerEXT debugUtilsCallbackHandle;
 
-- 
GitLab


From e0e7a899fbfda4212abfdd907482eadc18370b9b Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 4 Sep 2024 09:58:02 -0400
Subject: [PATCH 07/27] zink: hook up planar image creation with modifiers

---
 src/gallium/drivers/zink/zink_resource.c | 44 +++++++++++++++++++++---
 src/gallium/drivers/zink/zink_types.h    |  1 +
 2 files changed, 41 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index cc8f9c9f4db0a..775872e6de981 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -1735,7 +1735,43 @@ static struct pipe_resource *
 zink_resource_create_with_modifiers(struct pipe_screen *pscreen, const struct pipe_resource *templ,
                                     const uint64_t *modifiers, int modifiers_count)
 {
-   return resource_create(pscreen, templ, NULL, 0, modifiers, modifiers_count, NULL, NULL);
+   struct pipe_resource *pres = resource_create(pscreen, templ, NULL, 0, modifiers, modifiers_count, NULL, NULL);
+   if (!pres)
+      return NULL;
+   struct zink_resource *res = zink_resource(pres);
+   struct zink_resource *res_planes[3];
+   res_planes[0] = res;
+   unsigned num_planes = util_format_get_num_planes(templ->format);
+   for (unsigned p = 1; p < num_planes; p++) {
+      struct zink_resource *res_plane = CALLOC_STRUCT_CL(zink_resource);
+      res_plane->base.b = *templ;
+
+      threaded_resource_init(&res_plane->base.b, false);
+      pipe_reference_init(&res_plane->base.b.reference, 1);
+      res_plane->base.b.screen = pscreen;
+      zink_resource_object_reference(zink_screen(pscreen), &res_plane->obj, res->obj);
+
+      res_planes[p] = res_plane;
+
+      res_plane->base.b.format = util_format_get_plane_format(templ->format, p);
+      res_plane->modifiers_count = modifiers_count;
+      res_plane->modifiers = mem_dup(modifiers, modifiers_count * sizeof(uint64_t));
+      if (p == 1) {
+         res_planes[0]->base.b.format = util_format_get_plane_format(templ->format, 0);
+         res_planes[0]->base.b.next = &res_plane->base.b;
+      } else if (p == 2) {
+         res_planes[1]->base.b.next = &res_plane->base.b;
+      }
+      res_plane->plane = p;
+      res_plane->aspect = plane_aspects[p];
+      res_plane->internal_format = res_plane->base.b.format;
+   }
+   if (num_planes > 1) {
+      res->aspect = plane_aspects[0];
+      res->internal_format = res_planes[0]->base.b.format;
+   }
+
+   return pres;
 }
 
 static struct pipe_resource *
@@ -2013,12 +2049,12 @@ zink_resource_get_handle(struct pipe_screen *pscreen,
       whandle->handle = handle;
 #endif
       uint64_t value;
-      zink_resource_get_param(pscreen, context, tex, 0, 0, 0, PIPE_RESOURCE_PARAM_MODIFIER, 0, &value);
+      zink_resource_get_param(pscreen, context, tex, res->plane, 0, 0, PIPE_RESOURCE_PARAM_MODIFIER, 0, &value);
       whandle->modifier = value;
       if (!res->obj->is_buffer) {
-         zink_resource_get_param(pscreen, context, tex, 0, 0, 0, PIPE_RESOURCE_PARAM_OFFSET, 0, &value);
+         zink_resource_get_param(pscreen, context, tex, res->plane, 0, 0, PIPE_RESOURCE_PARAM_OFFSET, 0, &value);
          whandle->offset = value;
-         zink_resource_get_param(pscreen, context, tex, 0, 0, 0, PIPE_RESOURCE_PARAM_STRIDE, 0, &value);
+         zink_resource_get_param(pscreen, context, tex, res->plane, 0, 0, PIPE_RESOURCE_PARAM_STRIDE, 0, &value);
          whandle->stride = value;
       }
 #else
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index bc76a7e3c8ac0..9759cb9ab92fa 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -1306,6 +1306,7 @@ struct zink_resource {
    bool subdata; //doing subdata call
    unsigned dt_stride;
 
+   uint8_t plane;
    uint8_t modifiers_count;
    uint64_t *modifiers;
 };
-- 
GitLab


From c6150f6dba3692562e90156507b4df3807c05e49 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Mon, 22 Jul 2024 10:59:22 +1000
Subject: [PATCH 08/27] zink: block rendertarget clears for nonzero-plane
 images

---
 src/gallium/drivers/zink/zink_clear.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_clear.c b/src/gallium/drivers/zink/zink_clear.c
index 6968d0263ece5..735113090a9ff 100644
--- a/src/gallium/drivers/zink/zink_clear.c
+++ b/src/gallium/drivers/zink/zink_clear.c
@@ -568,7 +568,7 @@ zink_clear_render_target(struct pipe_context *pctx, struct pipe_surface *dst,
 {
    struct zink_context *ctx = zink_context(pctx);
    struct zink_resource *res = zink_resource(dst->texture);
-   if (width == 0 || height == 0)
+   if (width == 0 || height == 0 || res->plane > 0)
       return;
    if (!res->obj->render_target) {
       /* should only be hit by video */
-- 
GitLab


From 3904b1b0c0af72996c37b6cd6c9abe365a53946e Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 1 Oct 2024 13:07:23 +1000
Subject: [PATCH 09/27] zink: fix dedicated+disjoint image handling

---
 src/gallium/drivers/zink/zink_resource.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 775872e6de981..60fe1bd927b7b 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -1445,7 +1445,7 @@ create_image(struct zink_screen *screen, struct zink_resource_object *obj,
       assert(num_dmabuf_planes <= 4);
    }
 
-   alloc_info->need_dedicated = get_image_memory_requirement(screen, obj, num_planes, &reqs);
+   alloc_info->need_dedicated = get_image_memory_requirement(screen, obj, (ici.flags & VK_IMAGE_CREATE_DISJOINT_BIT) ? num_planes : 1, &reqs);
    if (templ->usage == PIPE_USAGE_STAGING && ici.tiling == VK_IMAGE_TILING_LINEAR)
       alloc_info->flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
    else
-- 
GitLab


From f6227c54d1ac834480562055e80916c8c508f8f6 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 1 Oct 2024 12:57:48 -0400
Subject: [PATCH 10/27] zink: block sampled image usage with video binds

technically this should use the video profile usage, but refactoring
into that is hard
---
 src/gallium/drivers/zink/zink_resource.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 60fe1bd927b7b..e7f213903d9e2 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -421,7 +421,7 @@ get_image_usage_for_feats(struct zink_screen *screen, VkFormatFeatureFlags2 feat
          usage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
       if (is_planar || (feats & VK_FORMAT_FEATURE_TRANSFER_DST_BIT))
          usage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT;
-      if (feats & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)
+      if (feats & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT && !(bind & ZINK_BIND_VIDEO))
          usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
 
       if ((is_planar || (feats & VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT)) && (bind & PIPE_BIND_SHADER_IMAGE)) {
-- 
GitLab


From 0ec15ba0ddf8f7dabe0507366b49a72a8a888442 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 1 Oct 2024 16:29:57 -0400
Subject: [PATCH 11/27] zink: fixup disjoint dmabuf creation to check for >1
 planes

somehow lost this during rebase
---
 src/gallium/drivers/zink/zink_resource.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index e7f213903d9e2..61bad21519fbf 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -568,7 +568,7 @@ find_good_mod(struct zink_screen *screen, VkImageCreateInfo *ici, const struct p
       if (!feats)
          continue;
 
-      if (feats & VK_FORMAT_FEATURE_DISJOINT_BIT && util_format_get_num_planes(templ->format))
+      if (feats & VK_FORMAT_FEATURE_DISJOINT_BIT && util_format_get_num_planes(templ->format) > 1)
          ici->flags |= VK_IMAGE_CREATE_DISJOINT_BIT;
       VkImageUsageFlags usage = get_image_usage_for_feats(screen, feats, templ, bind, &need_extended);
       assert(!need_extended);
-- 
GitLab


From 1cbbe183a26b32ece1b9ca85b57324aa8fa27717 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 1 Oct 2024 16:30:37 -0400
Subject: [PATCH 12/27] zink: implement screen::resource_get_info hook

slightly simpler than roundtripping get_param over and over
---
 src/gallium/drivers/zink/zink_resource.c | 34 ++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 61bad21519fbf..d62d717035bc8 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -1842,6 +1842,39 @@ zink_resource_is_aux_plane(struct pipe_resource *pres)
    return rsc->obj->is_aux;
 }
 
+static void
+zink_resource_get_info(struct pipe_screen *pscreen, struct pipe_resource *pres, unsigned *stride, unsigned *offset)
+{
+   struct zink_screen *screen = zink_screen(pscreen);
+   struct zink_resource *res = zink_resource(pres);
+   struct zink_resource_object *obj = res->obj;
+
+   VkImageAspectFlags aspect;
+   switch (res->plane) {
+   case 0:
+      aspect = VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT;
+      break;
+   case 1:
+      aspect = VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT;
+      break;
+   case 2:
+      aspect = VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
+      break;
+   case 3:
+      aspect = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
+      break;
+   default:
+      UNREACHABLE("how many planes you got in this thing?");
+   }
+   VkImageSubresource isr = {
+      aspect,
+   };
+   VkSubresourceLayout srl;
+   VKSCR(GetImageSubresourceLayout)(screen->dev, obj->image, &isr, &srl);
+   *offset = srl.offset;
+   *stride = srl.rowPitch;
+}
+
 static bool
 zink_resource_get_param(struct pipe_screen *pscreen, struct pipe_context *pctx,
                         struct pipe_resource *pres,
@@ -3324,6 +3357,7 @@ zink_screen_resource_init(struct pipe_screen *pscreen)
    if (screen->info.have_KHR_external_memory_fd || screen->info.have_KHR_external_memory_win32) {
       pscreen->resource_get_handle = zink_resource_get_handle;
       pscreen->resource_from_handle = zink_resource_from_handle;
+      pscreen->resource_get_info = zink_resource_get_info;
    }
    if (screen->info.have_EXT_external_memory_host) {
       pscreen->resource_from_user_memory = zink_resource_from_user_memory;
-- 
GitLab


From 2e86486c1802d998ba15d2a00c7c89ace48ce18f Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 4 Oct 2024 09:36:16 -0400
Subject: [PATCH 13/27] zink: disable HIC for video binds

this makes no sense
---
 src/gallium/drivers/zink/zink_resource.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index d62d717035bc8..8432b6d7772f3 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -469,8 +469,9 @@ get_image_usage_for_feats(struct zink_screen *screen, VkFormatFeatureFlags2 feat
    if (bind & PIPE_BIND_STREAM_OUTPUT)
       usage |= VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
 
-   /* Add host transfer if not sparse */
+   /* Add host transfer if not sparse or video */
    if (!(templ->flags & PIPE_RESOURCE_FLAG_SPARSE) &&
+       !(bind & ZINK_BIND_VIDEO) &&
        screen->info.have_EXT_host_image_copy &&
        feats & VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT)
       usage |= VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT;
-- 
GitLab


From 452c662737672159454c5b9b956586b8ca7b7e47 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 4 Oct 2024 09:57:42 -0400
Subject: [PATCH 14/27] zink: add INTERNAL_ONLY resource flag to disable
 import/exports

---
 src/gallium/drivers/zink/zink_resource.c | 4 ++--
 src/gallium/drivers/zink/zink_resource.h | 1 +
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 8432b6d7772f3..c2656e3314f64 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -911,7 +911,7 @@ struct mem_alloc_info {
 static inline bool
 get_export_flags(struct zink_screen *screen, const struct pipe_resource *templ, struct mem_alloc_info *alloc_info)
 {
-   bool needs_export = (templ->bind & (ZINK_BIND_VIDEO | ZINK_BIND_DMABUF)) != 0;
+   bool needs_export = templ->flags & ZINK_RESOURCE_FLAG_INTERNAL_ONLY ? false : (templ->bind & (ZINK_BIND_VIDEO | ZINK_BIND_DMABUF)) != 0;
    if (alloc_info->whandle) {
       if (alloc_info->whandle->type == WINSYS_HANDLE_TYPE_FD ||
           alloc_info->whandle->type == ZINK_EXTERNAL_MEMORY_HANDLE)
@@ -1508,7 +1508,7 @@ resource_object_create(struct zink_screen *screen, const struct pipe_resource *t
    struct mem_alloc_info alloc_info = {
       .whandle = whandle,
       .need_dedicated = false,
-      .export_types = ZINK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_BIT,
+      .export_types = templ->flags & ZINK_RESOURCE_FLAG_INTERNAL_ONLY ? 0 : ZINK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_BIT,
       .shared = templ->bind & PIPE_BIND_SHARED,
       .user_mem = user_mem
    };
diff --git a/src/gallium/drivers/zink/zink_resource.h b/src/gallium/drivers/zink/zink_resource.h
index c1ff178bd0d38..af7d93cc5dae9 100644
--- a/src/gallium/drivers/zink/zink_resource.h
+++ b/src/gallium/drivers/zink/zink_resource.h
@@ -33,6 +33,7 @@
 #define ZINK_BIND_DMABUF (1u << 29)
 #define ZINK_BIND_TRANSIENT (1u << 30) //transient fb attachment
 #define ZINK_BIND_VIDEO (1u << 31)
+#define ZINK_RESOURCE_FLAG_INTERNAL_ONLY (PIPE_RESOURCE_FLAG_DRV_PRIV << 2)
 
 #ifdef __cplusplus
 extern "C" {
-- 
GitLab


From 7563c2e7462cce0bb47d1c5a4b68cce10f9e3091 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 24 Nov 2021 13:29:48 +1000
Subject: [PATCH 15/27] zink/video: initial implementation

Co-authored-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/gallium/drivers/zink/meson.build     |   1 +
 src/gallium/drivers/zink/zink_resource.h |   4 +-
 src/gallium/drivers/zink/zink_video.c    | 833 +++++++++++++++++++++++
 src/gallium/drivers/zink/zink_video.h    | 116 ++++
 4 files changed, 953 insertions(+), 1 deletion(-)
 create mode 100644 src/gallium/drivers/zink/zink_video.c
 create mode 100644 src/gallium/drivers/zink/zink_video.h

diff --git a/src/gallium/drivers/zink/meson.build b/src/gallium/drivers/zink/meson.build
index 7727f396ff10a..11c257ffbfb5f 100644
--- a/src/gallium/drivers/zink/meson.build
+++ b/src/gallium/drivers/zink/meson.build
@@ -25,6 +25,7 @@ files_libzink = files(
   'zink_state.c',
   'zink_surface.c',
   'zink_synchronization.cpp',
+  'zink_video.c',
 )
 
 zink_device_info = custom_target(
diff --git a/src/gallium/drivers/zink/zink_resource.h b/src/gallium/drivers/zink/zink_resource.h
index af7d93cc5dae9..4a1e920bbbb15 100644
--- a/src/gallium/drivers/zink/zink_resource.h
+++ b/src/gallium/drivers/zink/zink_resource.h
@@ -32,7 +32,9 @@
 #define ZINK_BIND_MUTABLE (1u << 28)
 #define ZINK_BIND_DMABUF (1u << 29)
 #define ZINK_BIND_TRANSIENT (1u << 30) //transient fb attachment
-#define ZINK_BIND_VIDEO (1u << 31)
+#define ZINK_BIND_VIDEO (1u << 31) //from video frontend
+#define ZINK_RESOURCE_FLAG_VIDEO_DPB (PIPE_RESOURCE_FLAG_DRV_PRIV << 0) //separate video buffer
+#define ZINK_RESOURCE_FLAG_VIDEO_OUTPUT (PIPE_RESOURCE_FLAG_DRV_PRIV << 1) //separate video buffer
 #define ZINK_RESOURCE_FLAG_INTERNAL_ONLY (PIPE_RESOURCE_FLAG_DRV_PRIV << 2)
 
 #ifdef __cplusplus
diff --git a/src/gallium/drivers/zink/zink_video.c b/src/gallium/drivers/zink/zink_video.c
new file mode 100644
index 0000000000000..72eb3ce97d541
--- /dev/null
+++ b/src/gallium/drivers/zink/zink_video.c
@@ -0,0 +1,833 @@
+/*
+ * Copyright © 2021 Red Hat
+ * Copyright © 2021 Valve Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Dave Airlie <airlied@redhat.com>
+ *    Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
+ */
+
+#include "zink_context.h"
+#include "zink_resource.h"
+#include "zink_screen.h"
+#include "zink_surface.h"
+#include "zink_video.h"
+
+#include "util/u_video.h"
+#include "pipe/p_video_codec.h"
+#include "vl/vl_decoder.h"
+#include "vl/vl_video_buffer.h"
+
+#include "util/vl_zscan_data.h"
+
+#ifndef _WIN32
+#include "drm-uapi/drm_fourcc.h"
+#else
+/* these won't actually be used */
+#define DRM_FORMAT_MOD_INVALID 0
+#define DRM_FORMAT_MOD_LINEAR 0
+#endif
+
+static void
+zink_destroy_video_codec(struct pipe_video_codec *codec) {
+   struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
+   struct zink_screen *screen = (struct zink_screen *)zvc->screen;
+
+   if (!zvc->coincide_dpb) {
+      for (unsigned i = 0; i < zvc->max_dpb_slots; i++)
+         VKSCR(DestroyImageView)(screen->dev, zvc->dpb_resources[i].imageViewBinding, NULL);
+
+      if (zvc->dpb_array) {
+         pipe_resource_reference(&zvc->dpb_res[0], NULL);
+      } else {
+         for (unsigned i = 0; i < zvc->max_dpb_slots; i++) {
+            pipe_resource_reference(&zvc->dpb_res[i], NULL);
+         }
+      }
+   }
+   for (unsigned i = 0; i < NUM_BUFFERS; i++)
+      pipe_resource_reference(&zvc->bs[i], NULL);
+   for (unsigned i = 0; i < zvc->num_priv_mems; i++)
+      zink_bo_unref(screen, zvc->priv_mems[i]);
+
+   for (unsigned i = 0; i < 17; i++) {
+      if (zvc->render_pic_list[i])
+         vl_video_buffer_set_associated_data(zvc->render_pic_list[i], &zvc->base, NULL, NULL);
+   }
+   /* ensure session is no longer in use */
+   VKSCR(QueueWaitIdle)(screen->queue_video_decode);
+   VKSCR(DestroyCommandPool)(screen->dev, zvc->cmdpool, NULL);
+   VKSCR(DestroyVideoSessionKHR)(screen->dev,
+                                 zvc->session, NULL);
+   free(zvc);
+}
+
+static void
+zink_destroy_associated_data(void *data)
+{
+   struct zink_video_surf_data *surf = data;
+   struct zink_video_codec *zvc = (struct zink_video_codec *)surf->codec;
+   struct zink_screen *screen = (struct zink_screen *)zvc->screen;
+   VKSCR(DestroyImageView)(screen->dev, surf->resource.imageViewBinding, NULL);
+
+   for (unsigned i = 0; i < zvc->max_dpb_slots; i++) {
+      if (zvc->render_pic_list[i] == data) {
+         zvc->render_pic_list[i] = NULL;
+      }
+   }
+   /* destroy iv */
+   free(surf);
+}
+
+static void
+zink_video_create_session(struct zink_video_codec *zvc,
+                          uint32_t width, uint32_t height,
+                          enum pipe_format format,
+                          enum pipe_video_profile profile,
+                          enum pipe_video_entrypoint entrypoint)
+{
+   struct zink_screen *screen = (struct zink_screen *)zvc->base.context->screen;
+   uint32_t bit_depth = zink_video_get_format_bit_depth(format);
+   struct zink_video_profile vk_profile = { 0 };
+   zink_video_fill_single_profile(screen, profile, bit_depth, &vk_profile);
+
+   struct zink_video_caps_info caps_info = { 0 };
+   zink_video_fill_caps(screen, profile,
+                        entrypoint, bit_depth != 8, &caps_info);
+
+   zvc->max_dpb_slots = caps_info.caps.maxDpbSlots;
+   zvc->coincide_dpb = caps_info.dec_caps.flags & VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR;
+   zvc->dpb_array = !(caps_info.caps.flags & VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR);
+   if (!zvc->coincide_dpb) {
+      struct pipe_resource dpb_templ = {};
+      struct pipe_surface psurf = {};
+      dpb_templ.width0 = width;
+      dpb_templ.height0 = height * 2;
+      dpb_templ.depth0 = 1;
+      dpb_templ.format = format,
+      dpb_templ.target = PIPE_TEXTURE_2D;
+      dpb_templ.usage = PIPE_USAGE_DEFAULT;
+      dpb_templ.flags = ZINK_RESOURCE_FLAG_VIDEO_DPB | PIPE_RESOURCE_FLAG_DONT_MAP_DIRECTLY | ZINK_RESOURCE_FLAG_INTERNAL_ONLY;
+      dpb_templ.bind = ZINK_BIND_VIDEO;
+      dpb_templ.array_size = 1;
+
+      psurf.format = format;
+
+      if (zvc->dpb_array) {
+         dpb_templ.array_size = zvc->max_dpb_slots;
+         dpb_templ.target = PIPE_TEXTURE_2D_ARRAY;
+         zvc->dpb_res[0] = screen->base.resource_create(&screen->base,
+                                                        &dpb_templ);
+         for (unsigned i = 0; i < zvc->max_dpb_slots; i++) {
+            psurf.first_layer = psurf.last_layer = i;
+            VkImageViewCreateInfo ivci = create_ivci(screen, zink_resource(zvc->dpb_res[0]),
+                                                     &psurf, PIPE_TEXTURE_2D);
+            zvc->dpb_resources[i].sType = VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
+            zvc->dpb_resources[i].pNext = NULL;
+            zvc->dpb_resources[i].codedExtent.width = width;
+            zvc->dpb_resources[i].codedExtent.height = height;
+            zvc->dpb_resources[i].baseArrayLayer = i;
+            VKSCR(CreateImageView)(screen->dev, &ivci, NULL, &zvc->dpb_resources[i].imageViewBinding);
+         }
+      } else {
+         for (unsigned i = 0; i < zvc->max_dpb_slots; i++) {
+            zvc->dpb_res[i] = screen->base.resource_create(&screen->base,
+                                                           &dpb_templ);
+            zvc->dpb_resources[i].sType = VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
+            zvc->dpb_resources[i].pNext = NULL;
+            zvc->dpb_resources[i].codedExtent.width = width;
+            zvc->dpb_resources[i].codedExtent.height = height;
+            VkImageViewCreateInfo ivci = create_ivci(screen, zink_resource(zvc->dpb_res[i]),
+                                                     &psurf, PIPE_TEXTURE_2D);
+            VKSCR(CreateImageView)(screen->dev, &ivci, NULL, &zvc->dpb_resources[i].imageViewBinding);
+         }
+      }
+   }
+
+   const VkExtensionProperties h264_props = {
+      VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME,
+      VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION
+   };
+
+   VkVideoSessionCreateInfoKHR sci = { 0 };
+   sci.sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR;
+   sci.pVideoProfile = &vk_profile.profile;
+   sci.maxCodedExtent.width = width;
+   sci.maxCodedExtent.height = height;
+   sci.pictureFormat = zink_get_format(screen, format);
+   sci.referencePictureFormat = zink_get_format(screen, format);
+   sci.maxActiveReferencePictures = caps_info.caps.maxActiveReferencePictures;
+   sci.maxDpbSlots = caps_info.caps.maxDpbSlots;
+   sci.pStdHeaderVersion = &h264_props;
+
+   VKSCR(CreateVideoSessionKHR)(screen->dev, &sci, NULL, &zvc->session);
+
+   uint32_t mem_req_count;
+   VKSCR(GetVideoSessionMemoryRequirementsKHR)(screen->dev, zvc->session,
+                                               &mem_req_count, NULL);
+   const uint32_t max_reqs = 8; //hacky
+   VkVideoSessionMemoryRequirementsKHR session_memory_reqs[max_reqs];
+
+   memset(session_memory_reqs, 0, sizeof(session_memory_reqs));
+   for (uint32_t i = 0; i < mem_req_count; i++) {
+      session_memory_reqs[i].sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR;
+   }
+   VKSCR(GetVideoSessionMemoryRequirementsKHR)(screen->dev, zvc->session,
+                                               &mem_req_count, session_memory_reqs);
+
+   zvc->num_priv_mems = mem_req_count;
+   zvc->priv_mems = calloc(sizeof(struct zink_bo *), mem_req_count);
+   assert(zvc->priv_mems);
+
+   VkBindVideoSessionMemoryInfoKHR bind_memory[max_reqs];
+   enum zink_heap heap = ZINK_HEAP_DEVICE_LOCAL;
+   for (unsigned i = 0; i < mem_req_count; i++) {
+      for (unsigned j = 0; !zvc->priv_mems[i] && j < screen->heap_count[heap]; j++) {
+         if (!(session_memory_reqs[i].memoryRequirements.memoryTypeBits & BITFIELD_BIT(screen->heap_map[heap][j])))
+            continue;
+         zvc->priv_mems[i] = zink_bo(zink_bo_create(screen, session_memory_reqs[i].memoryRequirements.size, session_memory_reqs[i].memoryRequirements.alignment, heap, ZINK_ALLOC_NO_SUBALLOC, screen->heap_map[heap][j], NULL));
+      }
+      VkDeviceMemory mem = zink_bo_get_mem(zvc->priv_mems[i]);
+      bind_memory[i].pNext = NULL;
+      bind_memory[i].sType = VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR;
+      bind_memory[i].memory = mem;
+      bind_memory[i].memoryBindIndex = session_memory_reqs[i].memoryBindIndex;
+      bind_memory[i].memoryOffset = 0;
+      bind_memory[i].memorySize = zink_bo_get_size(zvc->priv_mems[i]);
+   }
+   VKSCR(BindVideoSessionMemoryKHR)(screen->dev, zvc->session,
+                                    mem_req_count, bind_memory);
+
+   zvc->srcbuf_align = caps_info.caps.minBitstreamBufferSizeAlignment;
+}
+
+static void
+zink_begin_frame(struct pipe_video_codec *codec,
+                 struct pipe_video_buffer *target,
+                 struct pipe_picture_desc *picture)
+{
+   struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
+   zvc->bs_size = 0;
+   zvc->bs_ptr = pipe_buffer_map(zvc->base.context, zvc->bs[zvc->cur_bs_buf], PIPE_MAP_WRITE, &zvc->bs_xfer);
+
+   if (!zvc->session)
+      zink_video_create_session(zvc, codec->width, codec->height,
+                                target->buffer_format,
+                                codec->profile, codec->entrypoint);
+
+}
+
+static void
+zink_decode_macroblock(struct pipe_video_codec *codec,
+                       struct pipe_video_buffer *target,
+                       struct pipe_picture_desc *picture,
+                       const struct pipe_macroblock *macroblocks,
+                       unsigned num_macroblocks)
+{
+}
+
+static void
+zink_decode_bitstream(struct pipe_video_codec *codec,
+                        struct pipe_video_buffer *target,
+                        struct pipe_picture_desc *picture,
+                        unsigned num_buffers,
+                        const void * const *buffers,
+                        const unsigned *sizes)
+{
+   struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
+   for (unsigned i = 0; i < num_buffers; ++i) {
+      memcpy(zvc->bs_ptr, buffers[i], sizes[i]);
+      zvc->bs_size += sizes[i];
+      zvc->bs_ptr += sizes[i];
+   }
+}
+
+
+static void
+convert_pps_sps(struct pipe_picture_desc *picture,
+                StdVideoH264SequenceParameterSet *vsps,
+                StdVideoH264PictureParameterSet *vpps,
+                StdVideoH264ScalingLists *pps_scaling_list)
+{
+   struct pipe_h264_picture_desc *h264 = (struct pipe_h264_picture_desc *)picture;
+   struct pipe_h264_pps *pps = h264->pps;
+   struct pipe_h264_sps *sps = pps->sps;
+
+   vpps->flags.transform_8x8_mode_flag = pps->transform_8x8_mode_flag;
+   vpps->flags.redundant_pic_cnt_present_flag = pps->redundant_pic_cnt_present_flag;
+   vpps->flags.constrained_intra_pred_flag = pps->constrained_intra_pred_flag;
+   vpps->flags.deblocking_filter_control_present_flag = pps->deblocking_filter_control_present_flag;
+   vpps->flags.weighted_pred_flag = pps->weighted_pred_flag;
+   vpps->flags.entropy_coding_mode_flag = pps->entropy_coding_mode_flag;
+   vpps->flags.pic_scaling_matrix_present_flag = true;
+
+   vpps->num_ref_idx_l0_default_active_minus1 = pps->num_ref_idx_l0_default_active_minus1;
+   vpps->num_ref_idx_l1_default_active_minus1 = pps->num_ref_idx_l1_default_active_minus1;
+   vpps->weighted_bipred_idc = pps->weighted_bipred_idc;
+   vpps->pic_init_qp_minus26 = pps->pic_init_qp_minus26;
+//   vpps->pic_init_qs_minus26;
+   vpps->chroma_qp_index_offset = pps->chroma_qp_index_offset;
+   vpps->second_chroma_qp_index_offset = pps->second_chroma_qp_index_offset;
+
+   pps_scaling_list->scaling_list_present_mask = 0xff;
+
+   /* have to convert scaling matrix through zscan */
+   for (unsigned m = 0; m < 6; m++)
+      for (unsigned q = 0; q < 16; q++)
+         pps_scaling_list->ScalingList4x4[m][q] = pps->ScalingList4x4[m][vl_zscan_normal_16[q]];
+
+   for (unsigned m = 0; m < 6; m++)
+      for (unsigned q = 0; q < 64; q++)
+         pps_scaling_list->ScalingList8x8[m][q] = pps->ScalingList8x8[m][vl_zscan_normal[q]];
+
+
+   switch (h264->base.profile) {
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE:
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_CONSTRAINED_BASELINE:
+     vsps->profile_idc = STD_VIDEO_H264_PROFILE_IDC_BASELINE;
+     break;
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN:
+     vsps->profile_idc = STD_VIDEO_H264_PROFILE_IDC_MAIN;
+     break;
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_HIGH:
+     vsps->profile_idc = STD_VIDEO_H264_PROFILE_IDC_HIGH;
+     break;
+   default:
+     assert(0);
+   }
+   vsps->level_idc = STD_VIDEO_H264_LEVEL_IDC_1_0;
+
+   vsps->flags.direct_8x8_inference_flag = sps->direct_8x8_inference_flag;
+   vsps->flags.mb_adaptive_frame_field_flag = sps->mb_adaptive_frame_field_flag;
+   vsps->flags.frame_mbs_only_flag = sps->frame_mbs_only_flag;
+   vsps->flags.delta_pic_order_always_zero_flag = sps->delta_pic_order_always_zero_flag;
+   vsps->flags.separate_colour_plane_flag = sps->separate_colour_plane_flag;
+
+   vsps->bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
+   vsps->bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
+   vsps->log2_max_frame_num_minus4 = sps->log2_max_frame_num_minus4;
+   vsps->pic_order_cnt_type = sps->pic_order_cnt_type;
+   vsps->log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
+   vsps->max_num_ref_frames = sps->max_num_ref_frames;
+   vsps->chroma_format_idc = sps->chroma_format_idc;
+   vsps->pic_width_in_mbs_minus1 = sps->pic_width_in_mbs_minus1;
+   /* no interlace support */
+   vsps->pic_height_in_map_units_minus1 = sps->pic_height_in_mbs_minus1;
+}
+
+static struct zink_video_surf_data *
+create_surf(struct zink_video_codec *zvc,
+            struct pipe_video_buffer *target,
+            int dpb_index)
+{
+   struct zink_resource *luma = (struct zink_resource *)((struct vl_video_buffer *)target)->resources[0];
+   struct zink_screen *screen = (struct zink_screen *)zvc->screen;
+   struct zink_video_surf_data *surf = calloc(sizeof(*surf), 1);
+
+   surf->codec = zvc;
+   surf->resource.sType = VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
+   surf->resource.pNext = NULL;
+   surf->resource.codedExtent.width = target->width;
+   surf->resource.codedExtent.height = target->height;
+   surf->resource.imageViewBinding = VK_NULL_HANDLE;
+
+   surf->dpb_index = dpb_index;
+
+   struct pipe_surface psurf = {};
+   psurf.format = target->buffer_format;
+   VkImageViewCreateInfo ivci = create_ivci(screen, luma, &psurf, PIPE_TEXTURE_2D);
+
+   VKSCR(CreateImageView)(screen->dev, &ivci, NULL, &surf->resource.imageViewBinding);
+
+   return surf;
+}
+
+static void
+end_bitstream(struct zink_video_codec *zvc)
+{
+   zvc->bs_ptr = NULL;
+   pipe_buffer_unmap(zvc->base.context, zvc->bs_xfer);
+}
+
+static void
+end_coding(struct zink_screen *screen,
+           struct zink_video_codec *zvc,
+           VkCommandBuffer cmdbuf)
+{
+   VkVideoEndCodingInfoKHR eci = { 0 };
+   eci.sType = VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR;
+
+   VKSCR(CmdEndVideoCodingKHR)(cmdbuf, &eci);
+
+   struct zink_resource *zbs = (struct zink_resource *)zvc->bs[zvc->cur_bs_buf];
+   VkBufferMemoryBarrier2KHR bitstream_bmb;
+   bitstream_bmb.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR;
+   bitstream_bmb.pNext = NULL;
+   bitstream_bmb.srcStageMask = VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
+   bitstream_bmb.srcAccessMask = VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR;
+   bitstream_bmb.dstStageMask = VK_PIPELINE_STAGE_2_NONE_KHR;
+   bitstream_bmb.dstAccessMask = VK_ACCESS_2_NONE_KHR;
+   bitstream_bmb.srcQueueFamilyIndex = zbs->queue;
+   bitstream_bmb.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+   bitstream_bmb.buffer = zbs->obj->buffer;
+   bitstream_bmb.size = align64(zvc->bs_size, zvc->srcbuf_align);
+   bitstream_bmb.offset = 0;
+   zbs->queue = VK_QUEUE_FAMILY_IGNORED;
+
+   VkDependencyInfoKHR di = { 0 };
+   di.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR;
+   di.dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
+   di.bufferMemoryBarrierCount = 1;
+   di.pBufferMemoryBarriers = &bitstream_bmb;
+   /* TODO image barriers */
+   VKSCR(CmdPipelineBarrier2KHR)(cmdbuf, &di);
+
+   if (VKSCR(EndCommandBuffer)(cmdbuf) != VK_SUCCESS) {
+      debug_printf("vkEndCommandBuffer failed\n");
+   }
+
+   VkSubmitInfo si = {0};
+   si.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
+   si.waitSemaphoreCount = 0;
+   si.pWaitSemaphores = NULL;
+   si.signalSemaphoreCount = 0;
+   si.pSignalSemaphores = NULL;
+   VkPipelineStageFlags videoDecodeSubmitWaitStages = VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
+   si.pWaitDstStageMask = &videoDecodeSubmitWaitStages;
+   si.commandBufferCount = 1;
+   si.pCommandBuffers = &cmdbuf;
+
+   VKSCR(QueueSubmit)(screen->queue_video_decode, 1, &si, NULL);
+   VKSCR(QueueWaitIdle)(screen->queue_video_decode);
+   VKSCR(FreeCommandBuffers)(screen->dev, zvc->cmdpool, 1, &cmdbuf);
+   VKSCR(DestroyVideoSessionParametersKHR)(screen->dev,
+                                           zvc->params, NULL);
+
+   zvc->cur_bs_buf++;
+   zvc->cur_bs_buf %= NUM_BUFFERS;
+}
+
+static int
+zink_end_frame_h264(struct pipe_video_codec *codec,
+                    struct pipe_video_buffer *target,
+                    struct pipe_picture_desc *picture)
+{
+   struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
+   struct zink_screen *screen = (struct zink_screen *)zvc->screen;
+   struct pipe_h264_picture_desc *h264 = (struct pipe_h264_picture_desc *)picture;
+
+   int i, j;
+
+   end_bitstream(zvc);
+
+   struct zink_video_surf_data *surf = NULL;
+
+   for (i = 0; i < ARRAY_SIZE(zvc->render_pic_list); i++) {
+      for (j = 0; (h264->ref[j] != NULL) && (j < ARRAY_SIZE(zvc->render_pic_list)); j++) {
+            if (zvc->render_pic_list[i] == h264->ref[j])
+               break;
+            if (j == ARRAY_SIZE(zvc->render_pic_list) - 1)
+               zvc->render_pic_list[i] = NULL;
+            else if (h264->ref[j + 1] == NULL)
+               zvc->render_pic_list[i] = NULL;
+      }
+   }
+   for (i = 0; i < ARRAY_SIZE(zvc->render_pic_list); ++i) {
+      if (zvc->render_pic_list[i] && zvc->render_pic_list[i] == target) {
+         if (target->codec != NULL) {
+            surf = vl_video_buffer_get_associated_data(target, &zvc->base);
+         } else {
+            surf = create_surf(zvc, target, i);
+            vl_video_buffer_set_associated_data(target, &zvc->base, (void *)surf,
+                  &zink_destroy_associated_data);
+         }
+         break;
+      }
+   }
+   if (i == ARRAY_SIZE(zvc->render_pic_list)) {
+      for (i = 0; i < ARRAY_SIZE(zvc->render_pic_list); ++i) {
+         if (!zvc->render_pic_list[i]) {
+            zvc->render_pic_list[i] = target;
+            surf = create_surf(zvc, target, i);
+            vl_video_buffer_set_associated_data(target, &zvc->base, (void *)surf,
+                  &zink_destroy_associated_data);
+            break;
+         }
+      }
+   }
+
+   StdVideoDecodeH264ReferenceInfo h264_ref_info[17] = { 0 };
+   VkVideoDecodeH264DpbSlotInfoKHR h264_dpb_info[17] = { 0 };
+   VkVideoReferenceSlotInfoKHR ref_info[17] = { 0 };
+   int num_ref_frames = 0;
+   for (unsigned i = 0; i < h264->num_ref_frames; i++) {
+      struct pipe_video_buffer *ref = h264->ref[i];
+
+      if (!ref)
+         break;
+      num_ref_frames++;
+      struct zink_video_surf_data *rsurf = vl_video_buffer_get_associated_data(ref, &zvc->base);
+
+      h264_ref_info[i].PicOrderCnt[0] = h264->field_order_cnt_list[i][0];
+      h264_ref_info[i].PicOrderCnt[1] = h264->field_order_cnt_list[i][1];
+      h264_ref_info[i].FrameNum = h264->frame_num_list[i];
+      h264_ref_info[i].flags.top_field_flag = h264->top_is_reference[i];
+      h264_ref_info[i].flags.bottom_field_flag = h264->bottom_is_reference[i];
+      h264_ref_info[i].flags.used_for_long_term_reference = h264->is_long_term[i];
+
+      h264_dpb_info[i].sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR;
+      h264_dpb_info[i].pStdReferenceInfo = &h264_ref_info[i];
+
+      ref_info[i].sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR;
+      ref_info[i].slotIndex = rsurf->dpb_index;
+      ref_info[i].pNext = &h264_dpb_info[i];
+      ref_info[i].pPictureResource = zvc->coincide_dpb ? &rsurf->resource : &zvc->dpb_resources[rsurf->dpb_index];
+   }
+
+   StdVideoDecodeH264ReferenceInfo h264_setup_info = { 0 };
+   VkVideoDecodeH264DpbSlotInfoKHR h264_dpb_setup_info = { 0 };
+   VkVideoReferenceSlotInfoKHR setup_info;
+   h264_setup_info.PicOrderCnt[0] = h264->field_order_cnt[0];
+   h264_setup_info.PicOrderCnt[1] = h264->field_order_cnt[1];
+   h264_setup_info.FrameNum = h264->frame_num;
+
+   h264_dpb_setup_info.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR;
+   h264_dpb_setup_info.pStdReferenceInfo = &h264_setup_info;
+
+   setup_info.sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR;
+   setup_info.slotIndex = surf->dpb_index;
+   setup_info.pPictureResource = zvc->coincide_dpb ? &surf->resource : &zvc->dpb_resources[surf->dpb_index];
+   setup_info.pNext = &h264_dpb_setup_info;
+   /* this must be added to the list of 'bound resources' */
+   ref_info[num_ref_frames++] = setup_info;
+
+   StdVideoH264SequenceParameterSet sps = { 0 };
+   StdVideoH264PictureParameterSet pps = { 0 };
+   StdVideoH264ScalingLists pps_scaling_lists = { 0 };
+
+   pps.pScalingLists = &pps_scaling_lists;
+   convert_pps_sps(picture, &sps, &pps, &pps_scaling_lists);
+   pps.num_ref_idx_l0_default_active_minus1 = h264->num_ref_idx_l0_active_minus1;
+   pps.num_ref_idx_l1_default_active_minus1 = h264->num_ref_idx_l1_active_minus1;
+   VkVideoDecodeH264SessionParametersAddInfoKHR h264add = { 0 };
+   h264add.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR;
+   h264add.stdSPSCount = 1;
+   h264add.pStdSPSs = &sps;
+   h264add.stdPPSCount = 1;
+   h264add.pStdPPSs = &pps;
+
+   VkVideoDecodeH264SessionParametersCreateInfoKHR h264_create = { 0 };
+   h264_create.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR;
+   h264_create.maxStdSPSCount = 1;
+   h264_create.maxStdPPSCount = 1;
+   h264_create.pParametersAddInfo = &h264add;
+   VkVideoSessionParametersCreateInfoKHR pci = { 0 };
+   pci.sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;
+   pci.pNext = &h264_create;
+   pci.videoSession = zvc->session;
+
+   VKSCR(CreateVideoSessionParametersKHR)(screen->dev, &pci, NULL, &zvc->params);
+
+   VkCommandBuffer cmdbuf;
+   VkCommandBufferAllocateInfo cbai = {0};
+   cbai.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
+   cbai.commandPool = zvc->cmdpool;
+   cbai.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+   cbai.commandBufferCount = 1;
+
+   VKSCR(AllocateCommandBuffers)(screen->dev, &cbai, &cmdbuf);
+
+   VkCommandBufferBeginInfo cbbi = {0};
+   cbbi.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+   cbbi.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
+   VKSCR(BeginCommandBuffer)(cmdbuf, &cbbi);
+
+   VkVideoBeginCodingInfoKHR bci = { 0 };
+   bci.sType = VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR;
+   bci.videoSession = zvc->session;
+   bci.videoSessionParameters = zvc->params;
+   bci.referenceSlotCount = num_ref_frames;
+   bci.pReferenceSlots = ref_info;
+
+   VKSCR(CmdBeginVideoCodingKHR)(cmdbuf, &bci);
+
+   if (!zvc->reset_sent) {
+      VkVideoCodingControlInfoKHR cc = {0};
+      cc.sType = VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR;
+      cc.flags = VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR;
+      VKSCR(CmdControlVideoCodingKHR)(cmdbuf, &cc);
+      zvc->reset_sent = true;
+   }
+
+   struct zink_resource *zbs = (struct zink_resource *)zvc->bs[zvc->cur_bs_buf];
+   VkBufferMemoryBarrier2KHR bitstream_bmb;
+   bitstream_bmb.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR;
+   bitstream_bmb.pNext = NULL;
+   bitstream_bmb.srcStageMask = VK_PIPELINE_STAGE_2_NONE_KHR;
+   bitstream_bmb.srcAccessMask = VK_ACCESS_2_HOST_WRITE_BIT_KHR;
+   bitstream_bmb.dstStageMask = VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
+   bitstream_bmb.dstAccessMask = VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR;
+   bitstream_bmb.srcQueueFamilyIndex = zbs->queue;
+   bitstream_bmb.dstQueueFamilyIndex = screen->video_decode_queue;
+   bitstream_bmb.buffer = zbs->obj->buffer;
+   bitstream_bmb.size = align64(zvc->bs_size, zvc->srcbuf_align);
+   bitstream_bmb.offset = 0;
+   zbs->queue = screen->video_decode_queue;
+
+   VkDependencyInfoKHR di = { 0 };
+   di.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR;
+   di.dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
+   di.bufferMemoryBarrierCount = 1;
+   di.pBufferMemoryBarriers = &bitstream_bmb;
+   /* TODO image barriers */
+   VKSCR(CmdPipelineBarrier2KHR)(cmdbuf, &di);
+
+   StdVideoDecodeH264PictureInfo pi = { 0 };
+   pi.frame_num = h264->frame_num;
+   pi.PicOrderCnt[0] = h264->field_order_cnt[0];
+   pi.PicOrderCnt[1] = h264->field_order_cnt[1];
+   pi.flags.field_pic_flag = h264->field_pic_flag;
+   pi.flags.bottom_field_flag = h264->bottom_field_flag;
+   pi.flags.is_reference = h264->is_reference;
+
+   VkVideoDecodeH264PictureInfoKHR hpi = { 0 };
+   hpi.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR;
+   hpi.pStdPictureInfo = &pi;
+   hpi.sliceCount = h264->slice_count;
+   uint32_t slice_data_offsets[16] = {};
+   for (unsigned i = 0; i < h264->slice_count; i++) {
+      for (unsigned j = i + 1; j < h264->slice_count; j++) {
+         slice_data_offsets[j] += h264->slice_parameter.slice_data_size[i] + 3;
+      }
+   }
+   hpi.pSliceOffsets = slice_data_offsets;
+
+   VkVideoDecodeInfoKHR vdi = { 0 };
+   vdi.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR;
+   vdi.pNext = &hpi;
+   vdi.referenceSlotCount = num_ref_frames - 1;
+   vdi.pReferenceSlots = ref_info;
+   vdi.pSetupReferenceSlot = &setup_info;
+   vdi.dstPictureResource = surf->resource;
+
+
+   vdi.srcBuffer = zbs->obj->buffer;
+   vdi.srcBufferOffset = 0;
+   vdi.srcBufferRange = align64(zvc->bs_size, zvc->srcbuf_align);
+   VKSCR(CmdDecodeVideoKHR)(cmdbuf, &vdi);
+
+   end_coding(screen, zvc, cmdbuf);
+
+   return 0;
+}
+
+static void
+zink_video_flush(struct pipe_video_codec *codec) {
+}
+
+static struct pipe_video_codec *
+zink_create_video_codec(struct pipe_context *pctx, const struct pipe_video_codec *templat)
+{
+   struct zink_screen *screen = zink_screen(pctx->screen);
+   struct zink_video_codec *zvc = CALLOC_STRUCT(zink_video_codec);
+   if (!zvc) {
+      return NULL;
+   }
+
+   zvc->base = *templat;
+   zvc->base.destroy = zink_destroy_video_codec;
+   zvc->base.begin_frame = zink_begin_frame;
+   zvc->base.decode_macroblock = zink_decode_macroblock;
+   zvc->base.decode_bitstream = zink_decode_bitstream;
+   zvc->base.end_frame = zink_end_frame_h264;
+   zvc->base.flush = zink_video_flush;
+   zvc->base.context = pctx;
+
+   zvc->screen = pctx->screen;
+
+   VkCommandPoolCreateInfo cpci = {0};
+   cpci.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
+   cpci.queueFamilyIndex = screen->video_decode_queue;
+   if (VKSCR(CreateCommandPool)(screen->dev, &cpci, NULL, &zvc->cmdpool) != VK_SUCCESS)
+      return NULL;
+
+   for (unsigned i = 0; i < NUM_BUFFERS; i++) {
+      zvc->bs[i] = pipe_buffer_create(&screen->base, ZINK_BIND_VIDEO, PIPE_USAGE_STAGING,
+                                      zvc->base.width * zvc->base.height * (512 / (16 * 16)));
+   }
+   return &zvc->base;
+}
+
+static struct pipe_video_buffer *
+zink_video_buffer_create(struct pipe_context *pctx, const struct pipe_video_buffer *templ)
+{
+   struct zink_screen *screen = zink_screen(pctx->screen);
+   struct pipe_video_buffer vidbuf = *templ;
+   uint64_t *modifiers = NULL;
+   int modifiers_count = 0;
+   uint64_t mod[3] = { 0 };
+   int count;
+
+   vidbuf.bind |= ZINK_BIND_VIDEO;
+   pctx->screen->query_dmabuf_modifiers(pctx->screen, templ->buffer_format, 3, mod, NULL, &count);
+
+   if (pctx->screen->resource_create_with_modifiers) {
+      modifiers = mod;
+      modifiers_count = count;
+   }
+
+   struct zink_video_caps_info caps_info = { 0 };
+   zink_video_fill_caps(screen, PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN,
+                        PIPE_VIDEO_ENTRYPOINT_BITSTREAM, false,
+                        &caps_info);
+   if (caps_info.dec_caps.flags & VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR) {
+      vidbuf.flags = ZINK_RESOURCE_FLAG_VIDEO_DPB | ZINK_RESOURCE_FLAG_VIDEO_OUTPUT;
+   } else {
+      vidbuf.flags = ZINK_RESOURCE_FLAG_VIDEO_OUTPUT;
+   }
+
+   return vl_video_buffer_create_as_resource(pctx, &vidbuf, modifiers, modifiers_count);
+}
+
+static StdVideoH264ProfileIdc
+h264_profile_conv(enum pipe_video_profile profile)
+{
+   switch (profile) {
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN:
+      return STD_VIDEO_H264_PROFILE_IDC_MAIN;
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_HIGH:
+      return STD_VIDEO_H264_PROFILE_IDC_HIGH;
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE:
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_CONSTRAINED_BASELINE:
+      return STD_VIDEO_H264_PROFILE_IDC_BASELINE;
+   default:
+      assert(0);
+      return STD_VIDEO_H264_PROFILE_IDC_MAIN;
+   }
+
+}
+
+static VkVideoCodecOperationFlagsKHR
+convert_decode_op(enum pipe_video_format vid_format)
+{
+   switch (vid_format) {
+   case PIPE_VIDEO_FORMAT_MPEG4_AVC:
+      return VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR;
+   default:
+      assert(0);
+      return VK_VIDEO_CODEC_OPERATION_NONE_KHR;
+   }
+}
+
+bool
+zink_video_fill_single_profile(struct zink_screen *screen,
+                               enum pipe_video_profile profile,
+                               uint32_t luma_depth,
+                               struct zink_video_profile *out_prof)
+{
+   VkVideoComponentBitDepthFlagBitsKHR bit_depth;
+   enum pipe_video_format vid_format = u_reduce_video_profile(profile);
+
+   switch (luma_depth) {
+   case 10:
+      bit_depth = VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR;
+      break;
+   default:
+      bit_depth = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR;
+      break;
+   }
+
+   if (vid_format == PIPE_VIDEO_FORMAT_MPEG4_AVC &&
+       !screen->info.have_KHR_video_decode_h264)
+      return false;
+
+   out_prof->profile.sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR;
+
+   out_prof->profile.videoCodecOperation = convert_decode_op(vid_format);
+   out_prof->profile.chromaSubsampling = VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR;
+   out_prof->profile.lumaBitDepth = bit_depth;
+   out_prof->profile.chromaBitDepth = bit_depth;
+
+   switch (vid_format) {
+   case PIPE_VIDEO_FORMAT_MPEG4_AVC:
+      out_prof->h264.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR;
+      out_prof->h264.stdProfileIdc = h264_profile_conv(profile);
+      out_prof->h264.pictureLayout = VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR;
+      out_prof->profile.pNext = &out_prof->h264;
+      break;
+   default:
+      return false;
+   }
+   return true;
+}
+
+void
+zink_video_fill_profiles(struct zink_screen *screen,
+                         struct zink_video_profile_info *profiles,
+                         enum pipe_video_profile profile,
+                         uint32_t luma_depth)
+{
+   int profile_count = 0;
+   enum pipe_video_format vid_format = u_reduce_video_profile(profile);
+
+   if (screen->info.have_KHR_video_decode_h264 && (vid_format == PIPE_VIDEO_FORMAT_MPEG4_AVC ||
+                                                   vid_format == PIPE_VIDEO_FORMAT_UNKNOWN)) {
+      if (vid_format == PIPE_VIDEO_FORMAT_UNKNOWN)
+         profile = PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN;
+      if (zink_video_fill_single_profile(screen, profile, luma_depth, &profiles->h264)) {
+         profiles->profiles[profile_count] = profiles->h264.profile;
+         profile_count++;
+      }
+   }
+
+   profiles->list.sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
+   profiles->list.profileCount = profile_count;
+   profiles->list.pProfiles = profiles->profiles;
+}
+
+void
+zink_video_init(struct zink_context *ctx)
+{
+   ctx->base.create_video_codec = zink_create_video_codec;
+   ctx->base.create_video_buffer = zink_video_buffer_create;
+}
+
+bool
+zink_video_fill_caps(struct zink_screen *screen,
+                     enum pipe_video_profile profile,
+                     enum pipe_video_entrypoint entrypoint,
+                     bool bit_depth_10,
+                     struct zink_video_caps_info *caps_info)
+{
+   struct zink_video_profile vk_profile = { 0 };
+   if (!zink_video_fill_single_profile(screen, profile, bit_depth_10 ? 10 : 8, &vk_profile))
+      return false;
+
+   caps_info->caps.sType = VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR;
+   caps_info->caps.pNext = &caps_info->dec_caps;
+   caps_info->dec_caps.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR;
+
+   caps_info->dec_caps.pNext = &caps_info->h264_dec_caps;
+   caps_info->h264_dec_caps.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR;
+
+   return VKSCR(GetPhysicalDeviceVideoCapabilitiesKHR)(screen->pdev, &vk_profile.profile, &caps_info->caps) == VK_SUCCESS;
+}
diff --git a/src/gallium/drivers/zink/zink_video.h b/src/gallium/drivers/zink/zink_video.h
new file mode 100644
index 0000000000000..9fe2c1c3e21f1
--- /dev/null
+++ b/src/gallium/drivers/zink/zink_video.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright © 2021 Red Hat
+ * Copyright © 2021 Valve Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Dave Airlie <airlied@redhat.com>
+ *    Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
+ */
+
+#ifndef ZINK_VIDEO_H
+#define ZINK_VIDEO_H
+
+#include "pipe/p_video_codec.h"
+#include "zink_types.h"
+
+#define NUM_BUFFERS 4
+
+struct zink_video_codec {
+   struct pipe_video_codec base;
+   struct pipe_screen *screen;
+   void *bs_ptr;
+   size_t bs_size;
+   struct pipe_transfer *bs_xfer;
+   VkCommandPool cmdpool;
+   VkVideoSessionParametersKHR params;
+   struct pipe_resource *bs[NUM_BUFFERS];
+   unsigned cur_bs_buf;
+   unsigned num_priv_mems;
+   unsigned max_dpb_slots;
+   struct zink_bo **priv_mems;
+   VkVideoSessionKHR session;
+   bool reset_sent;
+   bool coincide_dpb;
+   bool dpb_array;
+   size_t srcbuf_align;
+   void *render_pic_list[17];
+   /* for separate dpb/dst storage */
+   struct pipe_resource *dpb_res[17];
+   VkVideoPictureResourceInfoKHR dpb_resources[17];
+};
+
+struct zink_video_surf_data {
+   VkVideoPictureResourceInfoKHR resource;
+   struct zink_video_codec *codec;
+   uint32_t dpb_index;
+};
+
+struct zink_video_profile {
+   VkVideoDecodeH264ProfileInfoKHR h264;
+   VkVideoProfileInfoKHR profile;
+};
+
+struct zink_video_profile_info {
+   struct zink_video_profile h264;
+   VkVideoProfileInfoKHR profiles[4];
+   VkVideoProfileListInfoKHR list;
+};
+
+void
+zink_video_fill_profiles(struct zink_screen *screen,
+			 struct zink_video_profile_info *profiles,
+                         enum pipe_video_profile profile, uint32_t luma_depth);
+
+struct zink_video_caps_info {
+   VkVideoCapabilitiesKHR caps;
+   VkVideoDecodeCapabilitiesKHR dec_caps;
+   VkVideoDecodeH264CapabilitiesKHR h264_dec_caps;
+};
+
+bool
+zink_video_fill_caps(struct zink_screen *screen,
+                     enum pipe_video_profile profile,
+                     enum pipe_video_entrypoint entrypoint,
+                     bool bit_depth_10,
+                     struct zink_video_caps_info *caps_info);
+bool
+zink_video_fill_single_profile(struct zink_screen *screen,
+                               enum pipe_video_profile profile,
+                               uint32_t luma_depth,
+                               struct zink_video_profile *out_prof);
+void
+zink_video_init(struct zink_context *ctx);
+
+static inline uint32_t
+zink_video_get_format_bit_depth(enum pipe_format format)
+{
+   switch (format) {
+   case PIPE_FORMAT_NV12:
+      return 8;
+   case PIPE_FORMAT_P010:
+      return 10;
+   default:
+      return 0;
+   }
+}
+
+#endif
-- 
GitLab


From e5eda64d725e1b476fa86eaf3316212ecc927556 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 4 Sep 2024 10:03:56 -0400
Subject: [PATCH 16/27] zink: add video format mappings

---
 src/gallium/drivers/zink/zink_screen.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index 02207fd525eb1..eb6a91930e87f 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -1868,6 +1868,11 @@ zink_get_format(struct zink_screen *screen, enum pipe_format format)
    if (format == PIPE_FORMAT_R4A4_UNORM)
       return VK_FORMAT_R4G4_UNORM_PACK8;
 
+   if (format == PIPE_FORMAT_NV12)
+      return VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
+   if (format == PIPE_FORMAT_P010)
+      return VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
+
    return ret;
 }
 
-- 
GitLab


From 41815aab5faff83576902283deddee27fdf62f77 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Mon, 22 Jul 2024 10:59:22 +1000
Subject: [PATCH 17/27] zink: enable va/video support

---
 meson.build                             |   3 +-
 src/gallium/drivers/zink/zink_context.c |   3 +
 src/gallium/drivers/zink/zink_screen.c  | 130 ++++++++++++++++++++++++
 src/gallium/drivers/zink/zink_types.h   |   9 ++
 src/gallium/drivers/zink/zink_video.c   |  30 ++++++
 src/gallium/drivers/zink/zink_video.h   |   7 ++
 src/gallium/targets/dri/meson.build     |   3 +-
 src/gallium/targets/va/meson.build      |   3 +-
 8 files changed, 185 insertions(+), 3 deletions(-)

diff --git a/meson.build b/meson.build
index 103a63225e7cd..ea1c0d02094de 100644
--- a/meson.build
+++ b/meson.build
@@ -686,11 +686,12 @@ _va_drivers = [
   with_gallium_r600,
   with_gallium_radeonsi,
   with_gallium_virgl,
+  with_gallium_zink,
 ]
 
 _va = get_option('gallium-va') \
   .require(_va_drivers.contains(true),
-           error_message : 'VA state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau, d3d12 (with option gallium-d3d12-video), virgl.')
+           error_message : 'VA state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau, zink, d3d12 (with option gallium-d3d12-video), virgl.')
 _dep_va_name = host_machine.system() == 'windows' ? 'libva-win32' : 'libva'
 dep_va = dependency(_dep_va_name, version : '>= 1.8.0', required : _va)
 if dep_va.found()
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 38d843e127d8e..7be48b310f9d9 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -36,6 +36,7 @@
 #include "zink_screen.h"
 #include "zink_state.h"
 #include "zink_surface.h"
+#include "zink_video.h"
 
 
 #include "nir/pipe_nir.h"
@@ -5594,6 +5595,8 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
          goto fail;
    }
 
+   zink_video_init(ctx);
+
    if (!is_copy_only && !is_compute_only) {
       ctx->base.create_texture_handle = zink_create_texture_handle;
       ctx->base.delete_texture_handle = zink_delete_texture_handle;
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index eb6a91930e87f..5fd81d1785b55 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -35,6 +35,7 @@
 #include "zink_query.h"
 #include "zink_resource.h"
 #include "zink_state.h"
+#include "zink_video.h"
 #include "nir_to_spirv/nir_to_spirv.h" // for SPIRV_VERSION
 
 #include "util/u_debug.h"
@@ -50,6 +51,9 @@
 
 #include "util/u_cpu_detect.h"
 
+#include "vl/vl_video_buffer.h"
+#include "vl/vl_decoder.h"
+
 #ifdef HAVE_LIBDRM
 #include <xf86drm.h>
 #include <fcntl.h>
@@ -2782,6 +2786,19 @@ check_base_requirements(struct zink_screen *screen)
    }
 }
 
+static bool
+check_video_requirements(struct zink_screen *screen)
+{
+   if (!screen->info.have_KHR_video_queue ||
+       !screen->info.have_KHR_video_decode_queue)
+      return false;
+
+   if (!screen->info.have_KHR_video_decode_h264)
+      return false;
+
+   return true;
+}
+
 static void
 zink_get_sample_pixel_grid(struct pipe_screen *pscreen, unsigned sample_count,
                            unsigned *width, unsigned *height)
@@ -2793,6 +2810,114 @@ zink_get_sample_pixel_grid(struct pipe_screen *pscreen, unsigned sample_count,
    *height = screen->maxSampleLocationGridSize[idx].height;
 }
 
+static int
+zink_get_video_param(struct pipe_screen *screen,
+                     enum pipe_video_profile profile,
+                     enum pipe_video_entrypoint entrypoint,
+                     enum pipe_video_cap param)
+{
+   struct zink_video_caps_info caps_info = { 0 };
+   bool is_supported = false;
+   if (entrypoint == PIPE_VIDEO_ENTRYPOINT_ENCODE) {
+      return 0;
+   }
+
+   switch (profile) {
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN:
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_HIGH:
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE:
+   case PIPE_VIDEO_PROFILE_MPEG4_AVC_CONSTRAINED_BASELINE:
+      is_supported = true;
+      break;
+   default:
+      break;
+   }
+
+   switch (param) {
+   case PIPE_VIDEO_CAP_PREFERRED_FORMAT:
+      return PIPE_FORMAT_NV12;
+   case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
+      return false;
+   default:
+      if (!is_supported)
+         return 0;
+   };
+
+   if (!is_supported)
+      return 0;
+
+   if (!zink_video_fill_caps(zink_screen(screen), profile, entrypoint, false, &caps_info))
+      return 0;
+   switch (param) {
+   case PIPE_VIDEO_CAP_SUPPORTED:
+      return true;
+   case PIPE_VIDEO_CAP_NPOT_TEXTURES:
+      return 1;
+   case PIPE_VIDEO_CAP_MAX_WIDTH:
+      return caps_info.caps.maxCodedExtent.width;
+   case PIPE_VIDEO_CAP_MAX_HEIGHT:
+      return caps_info.caps.maxCodedExtent.height;
+   case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
+      return false;
+   case PIPE_VIDEO_CAP_SUPPORTS_PROGRESSIVE:
+      return true;
+   case PIPE_VIDEO_CAP_MAX_LEVEL:
+      return caps_info.h264_dec_caps.maxLevelIdc;
+   default:
+      break;
+   }
+   return 0;
+}
+
+static bool
+zink_is_video_format_supported(struct pipe_screen *pscreen,
+                               enum pipe_format format,
+                               enum pipe_video_profile profile,
+                               enum pipe_video_entrypoint entrypoint)
+{
+   struct zink_screen *screen = zink_screen(pscreen);
+
+   if (entrypoint == PIPE_VIDEO_ENTRYPOINT_ENCODE) {
+      return false;
+   }
+
+   uint32_t bit_depth = zink_video_get_format_bit_depth(format);
+   if (bit_depth == 0)
+      return false;
+
+   if (screen->video_output_usage == 0) {
+      /* first time through work out the dpb vs output */
+      struct zink_video_format_prop prop_dpb;
+      VkResult ret = zink_fill_video_format_props(screen,
+                                                  VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR | VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR,
+                                                  PIPE_VIDEO_PROFILE_UNKNOWN, 8,
+                                                  &prop_dpb);
+      if (ret == VK_ERROR_FORMAT_NOT_SUPPORTED || ret == VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR)
+         screen->video_output_usage = VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR;
+      else
+         screen->video_output_usage = VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR | VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR;
+      free(prop_dpb.pVideoFormatProperties);
+   }
+
+   struct zink_video_format_prop prop_obj;
+   VkResult ret = zink_fill_video_format_props(screen,
+                                               screen->video_output_usage,
+                                               profile,
+                                               bit_depth, &prop_obj);
+
+   if (ret != VK_SUCCESS)
+      return false;
+
+   for (unsigned i = 0; i < prop_obj.videoFormatPropertyCount; i++) {
+      if (prop_obj.pVideoFormatProperties[i].format == zink_get_format(screen, format)) {
+         free(prop_obj.pVideoFormatProperties);
+         return true;
+      }
+   }
+   free(prop_obj.pVideoFormatProperties);
+   return false;
+}
+
 static void
 init_driver_workarounds(struct zink_screen *screen)
 {
@@ -3594,6 +3719,11 @@ zink_internal_create_screen(const struct pipe_screen_config *config, int64_t dev
       goto fail;
    populate_format_props(screen);
 
+   if (check_video_requirements(screen)) {
+      screen->base.get_video_param = zink_get_video_param;
+   }
+   screen->base.is_video_format_supported = zink_is_video_format_supported;
+
    slab_create_parent(&screen->transfer_pool, sizeof(struct zink_transfer), 16);
 
    screen->driconf.inline_uniforms = debug_get_bool_option("ZINK_INLINE_UNIFORMS", screen->is_cpu);
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index 9759cb9ab92fa..88fc2a48ca460 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -1339,6 +1339,11 @@ struct zink_format_props {
    VkFormatFeatureFlags2 bufferFeatures;
 };
 
+struct zink_video_format_prop {
+   uint32_t videoFormatPropertyCount;
+   VkVideoFormatPropertiesKHR *pVideoFormatProperties;
+};
+
 struct zink_screen {
    struct pipe_screen base;
 
@@ -1524,6 +1529,10 @@ struct zink_screen {
       bool general_depth_layout;
       bool general_layout;
    } driver_workarounds;
+
+   VkImageUsageFlags video_output_usage;
+   struct zink_video_format_prop video_format_prop_dpb;
+   struct zink_video_format_prop video_format_prop_output;
 };
 
 static inline struct zink_screen *
diff --git a/src/gallium/drivers/zink/zink_video.c b/src/gallium/drivers/zink/zink_video.c
index 72eb3ce97d541..a60b083129c2a 100644
--- a/src/gallium/drivers/zink/zink_video.c
+++ b/src/gallium/drivers/zink/zink_video.c
@@ -831,3 +831,33 @@ zink_video_fill_caps(struct zink_screen *screen,
 
    return VKSCR(GetPhysicalDeviceVideoCapabilitiesKHR)(screen->pdev, &vk_profile.profile, &caps_info->caps) == VK_SUCCESS;
 }
+
+VkResult
+zink_fill_video_format_props(struct zink_screen *screen,
+                             VkImageUsageFlags usage,
+                             enum pipe_video_profile profile,
+                             uint32_t bit_depth,
+                             struct zink_video_format_prop *props)
+{
+   struct zink_video_profile_info profiles = {0};
+   zink_video_fill_profiles(screen, &profiles, profile, bit_depth);
+
+   VkPhysicalDeviceVideoFormatInfoKHR video_format_info = {};
+   video_format_info.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;
+   video_format_info.pNext = &profiles.list;
+   video_format_info.imageUsage = usage;
+
+   props->pVideoFormatProperties = NULL;
+   VkResult ret = VKSCR(GetPhysicalDeviceVideoFormatPropertiesKHR)(screen->pdev, &video_format_info,
+                                                                   &props->videoFormatPropertyCount,
+                                                                   NULL);
+   if (ret != VK_SUCCESS)
+      return ret;
+   props->pVideoFormatProperties = calloc(props->videoFormatPropertyCount, sizeof(VkVideoFormatPropertiesKHR));
+   for (unsigned i = 0; i < props->videoFormatPropertyCount; i++)
+      props->pVideoFormatProperties[i].sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR;
+   VKSCR(GetPhysicalDeviceVideoFormatPropertiesKHR)(screen->pdev, &video_format_info,
+                                                    &props->videoFormatPropertyCount,
+                                                    props->pVideoFormatProperties);
+   return VK_SUCCESS;
+}
diff --git a/src/gallium/drivers/zink/zink_video.h b/src/gallium/drivers/zink/zink_video.h
index 9fe2c1c3e21f1..ca97ce358d734 100644
--- a/src/gallium/drivers/zink/zink_video.h
+++ b/src/gallium/drivers/zink/zink_video.h
@@ -113,4 +113,11 @@ zink_video_get_format_bit_depth(enum pipe_format format)
    }
 }
 
+VkResult
+zink_fill_video_format_props(struct zink_screen *screen,
+                             VkImageUsageFlags usage,
+                             enum pipe_video_profile profile,
+                             uint32_t bit_depth,
+                             struct zink_video_format_prop *props);
+
 #endif
diff --git a/src/gallium/targets/dri/meson.build b/src/gallium/targets/dri/meson.build
index 6a2c6e94b900d..10639358251dd 100644
--- a/src/gallium/targets/dri/meson.build
+++ b/src/gallium/targets/dri/meson.build
@@ -77,7 +77,8 @@ if with_gallium_va or with_gallium_vdpau
               [with_gallium_radeonsi, 'radeonsi'],
               [with_gallium_nouveau, 'nouveau'],
               [with_gallium_virgl, 'virtio_gpu'],
-              [with_gallium_d3d12_video, 'd3d12']]
+              [with_gallium_d3d12_video, 'd3d12'],
+              [with_gallium_zink, 'zink']]
     if d[0]
       if with_gallium_va
         va_drivers += '@0@_drv_video.so'.format(d[1])
diff --git a/src/gallium/targets/va/meson.build b/src/gallium/targets/va/meson.build
index efd8895632102..65c4c0c344ab2 100644
--- a/src/gallium/targets/va/meson.build
+++ b/src/gallium/targets/va/meson.build
@@ -78,7 +78,7 @@ else
     link_whole : [libva_st],
     link_with : link_with_libva_gallium,
     dependencies : [
-      dep_libdrm, driver_r600, driver_radeonsi, driver_nouveau, driver_d3d12, driver_virgl,
+      dep_libdrm, driver_r600, driver_radeonsi, driver_nouveau, driver_d3d12, driver_virgl, driver_zink,
       idep_mesautil,
     ],
     link_depends : va_link_depends,
@@ -91,6 +91,7 @@ else
               [with_gallium_radeonsi, 'radeonsi'],
               [with_gallium_nouveau, 'nouveau'],
               [with_gallium_virgl, 'virtio_gpu'],
+              [with_gallium_zink, 'zink'],
               [with_gallium_d3d12_video, 'd3d12']]
     if d[0]
       va_drivers += '@0@_drv_video.so'.format(d[1])
-- 
GitLab


From f8259abcf7e29a3800accc4e70548ffdce0ed94a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 4 Sep 2024 10:03:07 -0400
Subject: [PATCH 18/27] zink: implement video resource binding

this should handle all the necessary feature checks
---
 src/gallium/drivers/zink/zink_resource.c | 73 ++++++++++++++++++++++--
 1 file changed, 67 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index c2656e3314f64..2611cd189ded6 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -32,6 +32,7 @@
 #include "zink_screen.h"
 #include "zink_surface.h"
 #include "zink_kopper.h"
+#include "zink_video.h"
 
 #ifdef VK_USE_PLATFORM_METAL_EXT
 #include "QuartzCore/CAMetalLayer.h"
@@ -318,6 +319,11 @@ create_bci(struct zink_screen *screen, const struct pipe_resource *templ, unsign
                       VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
       }
    }
+   if (bind & ZINK_BIND_VIDEO) {
+      bci.usage |= VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR;
+      // with KHR_video_maintenance1
+      // bci.flags |= VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR;
+   }
    if (screen->info.have_KHR_buffer_device_address)
       bci.usage |= VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
 
@@ -430,7 +436,12 @@ get_image_usage_for_feats(struct zink_screen *screen, VkFormatFeatureFlags2 feat
       }
    }
 
-   if (bind & PIPE_BIND_RENDER_TARGET) {
+   if (bind & ZINK_BIND_VIDEO) {
+      if (templ->flags & ZINK_RESOURCE_FLAG_VIDEO_DPB)
+         usage |= VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR;
+      if (templ->flags & ZINK_RESOURCE_FLAG_VIDEO_OUTPUT)
+         usage |= VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR;
+   } else if (bind & PIPE_BIND_RENDER_TARGET) {
       if (feats & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT) {
          usage |= VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
          if (!(bind & ZINK_BIND_TRANSIENT) && (bind & (PIPE_BIND_LINEAR | PIPE_BIND_SHARED)) != (PIPE_BIND_LINEAR | PIPE_BIND_SHARED))
@@ -702,6 +713,12 @@ eval_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
          }
       }
    }
+   if (templ->bind & ZINK_BIND_VIDEO) {
+      if (!(ici->usage & (VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR|VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR))) {
+         *success = false;
+         return DRM_FORMAT_MOD_INVALID;
+      }
+   }
    if (want_cube) {
       ici->flags |= VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
       VkImageUsageFlags usage = ici->usage;
@@ -715,7 +732,7 @@ eval_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
    return mod;
 }
 
-static void
+static bool
 init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_resource *templ, unsigned bind, unsigned modifiers_count)
 {
    ici->sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
@@ -727,6 +744,35 @@ init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
    ici->arrayLayers = MAX2(templ->array_size, 1);
    ici->samples = templ->nr_samples ? templ->nr_samples : VK_SAMPLE_COUNT_1_BIT;
 
+   ici->usage = 0;
+   ici->queueFamilyIndexCount = 0;
+   ici->pQueueFamilyIndices = NULL;
+   if (bind & ZINK_BIND_VIDEO) {
+      struct zink_video_format_prop prop_obj;
+      uint32_t bit_depth = zink_video_get_format_bit_depth(templ->format);
+      bool found = false;
+      VkResult ret = zink_fill_video_format_props(screen,
+                                                  screen->video_output_usage,
+                                                  PIPE_VIDEO_FORMAT_UNKNOWN,
+                                                  bit_depth, &prop_obj);
+      if (ret != VK_SUCCESS)
+         return false;
+
+      for (unsigned i = 0; i < prop_obj.videoFormatPropertyCount; i++) {
+         VkVideoFormatPropertiesKHR *fprop = &prop_obj.pVideoFormatProperties[i];
+         if (fprop->format != ici->format)
+            continue;
+         if (modifiers_count && fprop->imageTiling == VK_IMAGE_TILING_OPTIMAL)
+            continue;
+         if (!(fprop->imageCreateFlags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT))
+            continue;
+         found = true;
+         break;
+      }
+      free(prop_obj.pVideoFormatProperties);
+      if (!found)
+         return false;
+   }
    /* pNext may already be set */
    if (bind & ZINK_BIND_MUTABLE)
       ici->flags = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
@@ -738,9 +784,6 @@ init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
    else if (ici->pNext)
       /* add mutable if VkImageFormatListCreateInfo */
       ici->flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
-   ici->usage = 0;
-   ici->queueFamilyIndexCount = 0;
-   ici->pQueueFamilyIndices = NULL;
 
    /* assume we're going to be doing some CompressedTexSubImage */
    if (util_format_is_compressed(templ->format) && (ici->flags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT) &&
@@ -808,6 +851,7 @@ init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
 
    if (templ->target == PIPE_TEXTURE_CUBE)
       ici->arrayLayers *= 6;
+   return true;
 }
 
 static const VkImageAspectFlags plane_aspects[] = {
@@ -1203,6 +1247,13 @@ create_buffer(struct zink_screen *screen, struct zink_resource_object *obj,
       bci.pNext = &embci;
    }
 
+   struct zink_video_profile_info profiles = {0};
+   zink_video_fill_profiles(screen, &profiles, PIPE_VIDEO_PROFILE_UNKNOWN, 8);
+   if (templ->bind & ZINK_BIND_VIDEO) {
+      profiles.list.pNext = bci.pNext;
+      bci.pNext = &profiles.list;
+   }
+
    if (VKSCR(CreateBuffer)(screen->dev, &bci, NULL, &obj->buffer) != VK_SUCCESS) {
       mesa_loge("ZINK: vkCreateBuffer failed");
       return roc_fail_and_free_object;
@@ -1279,6 +1330,8 @@ create_image(struct zink_screen *screen, struct zink_resource_object *obj,
    }
    VkFormat formats[4] = {VK_FORMAT_UNDEFINED};
    VkImageFormatListCreateInfo format_list;
+   struct zink_video_profile_info vid_profile = { 0 };
+
    if (srgb) {
       formats[0] = zink_get_format(screen, templ->format);
       formats[1] = zink_get_format(screen, srgb);
@@ -1297,7 +1350,15 @@ create_image(struct zink_screen *screen, struct zink_resource_object *obj,
    } else {
       ici.pNext = NULL;
    }
-   init_ici(screen, &ici, templ, templ->bind, ici_modifier_count);
+   if (!init_ici(screen, &ici, templ, templ->bind, ici_modifier_count))
+      return roc_fail_and_free_object;
+
+   if (templ->bind & ZINK_BIND_VIDEO) {
+      uint32_t bit_depth = zink_video_get_format_bit_depth(templ->format);
+      zink_video_fill_profiles(screen, &vid_profile, PIPE_VIDEO_PROFILE_UNKNOWN, bit_depth);
+      vid_profile.list.pNext = ici.pNext;
+      ici.pNext = &vid_profile.list;
+   }
 
    bool success = false;
    uint64_t mod = eval_ici(screen, &ici, templ, templ->bind, ici_modifier_count, ici_modifiers, &success);
-- 
GitLab


From ec6596b19a0826164c002663ebc85eab2b8670b5 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Fri, 4 Oct 2024 16:50:58 +1000
Subject: [PATCH 19/27] zink/video: drop optimal check for now

This broke stuff
---
 src/gallium/drivers/zink/zink_resource.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 2611cd189ded6..8b9a8011a8149 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -762,8 +762,6 @@ init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
          VkVideoFormatPropertiesKHR *fprop = &prop_obj.pVideoFormatProperties[i];
          if (fprop->format != ici->format)
             continue;
-         if (modifiers_count && fprop->imageTiling == VK_IMAGE_TILING_OPTIMAL)
-            continue;
          if (!(fprop->imageCreateFlags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT))
             continue;
          found = true;
-- 
GitLab


From d9a566e81562c406823fefb7de590d2331ce3ca5 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 25 Oct 2024 08:25:41 -0400
Subject: [PATCH 20/27] zink: add util for gpu-syncing copy context with
 current context

---
 src/gallium/drivers/zink/zink_batch.c | 19 +++++++++++++++++--
 src/gallium/drivers/zink/zink_batch.h |  2 ++
 src/gallium/drivers/zink/zink_types.h |  1 +
 3 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_batch.c b/src/gallium/drivers/zink/zink_batch.c
index 3f04db6a2044c..65fde212a7577 100644
--- a/src/gallium/drivers/zink/zink_batch.c
+++ b/src/gallium/drivers/zink/zink_batch.c
@@ -120,6 +120,7 @@ reset_batch_state_internal(struct zink_screen *screen, struct zink_batch_state *
    util_dynarray_clear(&bs->user_signal_semaphore_values);
 
    bs->present = VK_NULL_HANDLE;
+   bs->copy_context_semaphore = VK_NULL_HANDLE;
    /* check the arrays first to avoid locking unnecessarily */
    if (util_dynarray_contains(&bs->acquires, VkSemaphore) || util_dynarray_contains(&bs->tracked_semaphores, VkSemaphore)) {
       simple_mtx_lock(&screen->semaphores_lock);
@@ -793,8 +794,11 @@ submit_queue(void *data, void *gdata, int thread_index)
    VkSemaphore *sem = bs->signal_semaphores.data;
    set_foreach(&bs->dmabuf_exports, entry) {
       struct zink_resource *res = (void*)entry->key;
-      for (; res; res = zink_resource(res->base.b.next))
-         zink_screen_import_dmabuf_semaphore(screen, res, sem[i++]);
+      for (; res; res = zink_resource(res->base.b.next)) {
+         /* copy_context_semaphore is a special signal */
+         if (sem[i] != bs->copy_context_semaphore)
+            zink_screen_import_dmabuf_semaphore(screen, res, sem[i++]);
+      }
 
       struct pipe_resource *pres = (void*)entry->key;
       pipe_resource_reference(&pres, NULL);
@@ -1200,3 +1204,14 @@ zink_batch_usage_try_wait(struct zink_context *ctx, struct zink_batch_usage *u,
 {
    batch_usage_wait(ctx, u, submit_count, true);
 }
+
+void
+zink_batch_sync_with_copy_context(struct zink_context *ctx)
+{
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
+   screen->copy_context->bs->copy_context_semaphore = zink_create_semaphore(screen);
+   util_dynarray_append(&screen->copy_context->bs->signal_semaphores, VkSemaphore, screen->copy_context->bs->copy_context_semaphore);
+   VkPipelineStageFlags flag = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+   util_dynarray_append(&ctx->bs->wait_semaphores, VkSemaphore, screen->copy_context->bs->copy_context_semaphore);
+   util_dynarray_append(&ctx->bs->wait_semaphore_stages, VkPipelineStageFlags, flag);
+}
diff --git a/src/gallium/drivers/zink/zink_batch.h b/src/gallium/drivers/zink/zink_batch.h
index cc0cdfee57969..7f630aeb445a8 100644
--- a/src/gallium/drivers/zink/zink_batch.h
+++ b/src/gallium/drivers/zink/zink_batch.h
@@ -141,6 +141,8 @@ zink_batch_usage_wait(struct zink_context *ctx, struct zink_batch_usage *u, unsi
 void
 zink_batch_usage_try_wait(struct zink_context *ctx, struct zink_batch_usage *u, unsigned submit_count);
 
+void
+zink_batch_sync_with_copy_context(struct zink_context *ctx);
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index 88fc2a48ca460..6e441a0fdbfdb 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -601,6 +601,7 @@ struct zink_batch_state {
    VkCommandBuffer reordered_cmdbuf;
    VkCommandPool unsynchronized_cmdpool;
    VkCommandBuffer unsynchronized_cmdbuf;
+   VkSemaphore copy_context_semaphore; //reusable signal semaphore for copy context sync
    VkSemaphore signal_semaphore; //external signal semaphore
    struct util_dynarray signal_semaphores; //internal signal semaphores
    struct util_dynarray user_signal_semaphores; //api signal semaphores
-- 
GitLab


From 52572606a8cfd3670d863a479317401d5481ddf9 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Oct 2024 12:47:18 -0400
Subject: [PATCH 21/27] gallium: add PIPE_CONTEXT_VIDEO flag

this indicates that the context is from a video frontend
---
 src/gallium/auxiliary/util/u_inlines.h | 2 +-
 src/gallium/include/pipe/p_defines.h   | 5 +++++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/util/u_inlines.h b/src/gallium/auxiliary/util/u_inlines.h
index 80dcb58382a6c..57783ffc71d8b 100644
--- a/src/gallium/auxiliary/util/u_inlines.h
+++ b/src/gallium/auxiliary/util/u_inlines.h
@@ -970,7 +970,7 @@ util_writes_depth_stencil(const struct pipe_depth_stencil_alpha_state *zsa)
 static inline struct pipe_context *
 pipe_create_multimedia_context(struct pipe_screen *screen, bool compute_only)
 {
-   unsigned flags = 0;
+   unsigned flags = PIPE_CONTEXT_VIDEO;
 
    if (!screen->caps.graphics && !screen->caps.compute)
       flags |= PIPE_CONTEXT_MEDIA_ONLY;
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 5f9065fc89cd1..68177ff94a1e5 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -394,6 +394,11 @@ enum pipe_flush_flags
  */
 #define PIPE_CONTEXT_PROTECTED         (1 << 7)
 
+/** 
+ * create a context to be used by video frontends
+ */
+#define PIPE_CONTEXT_VIDEO         (1 << 8)
+
 /**
  * Create a context that does not use sampler LOD bias. If this is set, the
  * frontend MUST set pipe_sampler_state::lod_bias to 0.0f for all samplers used
-- 
GitLab


From 4d0da4ea09c6b2d4433bb221bc8d2a4483c1a210 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Oct 2024 12:47:50 -0400
Subject: [PATCH 22/27] vl/kopper: use multimedia context create

---
 src/gallium/auxiliary/vl/vl_winsys_kopper.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gallium/auxiliary/vl/vl_winsys_kopper.c b/src/gallium/auxiliary/vl/vl_winsys_kopper.c
index c5bcfae031c1c..7e9988035f1e5 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_kopper.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_kopper.c
@@ -218,7 +218,7 @@ vl_kopper_screen_create_x11(Display *display, int screen)
    scrn->base.texture_from_drawable = vl_kopper_texture_from_drawable;
    scrn->base.get_dirty_area = vl_kopper_get_dirty_area;
    scrn->base.destroy = vl_kopper_screen_destroy;
-   scrn->pipe = scrn->base.pscreen->context_create(scrn->base.pscreen, NULL, 0);
+   scrn->pipe = pipe_create_multimedia_context(scrn->base.pscreen, false);
 
    vl_compositor_reset_dirty_area(&scrn->dirty_area);
 
@@ -246,7 +246,7 @@ vl_kopper_screen_create_win32(LUID *luid)
 
    scrn->base.destroy = vl_kopper_screen_destroy;
 
-   scrn->pipe = scrn->base.pscreen->context_create(scrn->base.pscreen, NULL, 0);
+   scrn->pipe = pipe_create_multimedia_context(scrn->base.pscreen, false);
 
    return &scrn->base;
 
-- 
GitLab


From 7366919bf00091615be4fd1248c74458a55b7d9f Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Oct 2024 12:48:56 -0400
Subject: [PATCH 23/27] zink: handle PIPE_CONTEXT_VIDEO everywhere

this makes batches magically work with video queues
---
 src/gallium/drivers/zink/zink_batch.c    | 23 +++++----
 src/gallium/drivers/zink/zink_context.c  | 61 +++++++++++++-----------
 src/gallium/drivers/zink/zink_resource.c | 12 +++++
 3 files changed, 60 insertions(+), 36 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_batch.c b/src/gallium/drivers/zink/zink_batch.c
index 65fde212a7577..6ef7b68ebb119 100644
--- a/src/gallium/drivers/zink/zink_batch.c
+++ b/src/gallium/drivers/zink/zink_batch.c
@@ -301,9 +301,10 @@ create_batch_state(struct zink_context *ctx)
 {
    struct zink_screen *screen = zink_screen(ctx->base.screen);
    struct zink_batch_state *bs = rzalloc(NULL, struct zink_batch_state);
+   bs->ctx = ctx;
    VkCommandPoolCreateInfo cpci = {0};
    cpci.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
-   cpci.queueFamilyIndex = screen->gfx_queue;
+   cpci.queueFamilyIndex = bs->ctx->flags & PIPE_CONTEXT_VIDEO ? screen->video_decode_queue : screen->gfx_queue;
    VkResult result;
 
    VRAM_ALLOC_LOOP(result,
@@ -355,8 +356,6 @@ create_batch_state(struct zink_context *ctx)
 #define SET_CREATE(ptr) \
    _mesa_set_init(ptr, bs, _mesa_hash_pointer, _mesa_key_pointer_equal)
 
-   bs->ctx = ctx;
-
    SET_CREATE(&bs->programs);
    SET_CREATE(&bs->active_queries);
    SET_CREATE(&bs->dmabuf_exports);
@@ -581,7 +580,7 @@ zink_start_batch(struct zink_context *ctx)
    if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB && !(ctx->flags & ZINK_CONTEXT_COPY_ONLY))
       zink_batch_bind_db(ctx);
    /* zero init for unordered blits */
-   if (screen->info.have_EXT_attachment_feedback_loop_dynamic_state) {
+   if (!(ctx->flags & PIPE_CONTEXT_VIDEO) && screen->info.have_EXT_attachment_feedback_loop_dynamic_state) {
       VKCTX(CmdSetAttachmentFeedbackLoopEnableEXT)(ctx->bs->cmdbuf, 0);
       VKCTX(CmdSetAttachmentFeedbackLoopEnableEXT)(ctx->bs->reordered_cmdbuf, 0);
       VKCTX(CmdSetAttachmentFeedbackLoopEnableEXT)(ctx->bs->unsynchronized_cmdbuf, 0);
@@ -694,6 +693,11 @@ submit_queue(void *data, void *gdata, int thread_index)
       cmdbufs[c++] = bs->cmdbuf;
    si[ZINK_SUBMIT_CMDBUF].pCommandBuffers = cmdbufs;
    si[ZINK_SUBMIT_CMDBUF].commandBufferCount = c;
+
+   /* this only needs to be added for the submit call */
+   if (bs->copy_context_semaphore)
+      util_dynarray_append(&bs->signal_semaphores, VkSemaphore, bs->copy_context_semaphore);
+
    /* assorted signal submit from wsi/externals */
    si[ZINK_SUBMIT_CMDBUF].signalSemaphoreCount = util_dynarray_num_elements(&bs->signal_semaphores, VkSemaphore);
    si[ZINK_SUBMIT_CMDBUF].pSignalSemaphores = bs->signal_semaphores.data;
@@ -782,7 +786,7 @@ submit_queue(void *data, void *gdata, int thread_index)
 
    simple_mtx_lock(&screen->queue_lock);
    VRAM_ALLOC_LOOP(result,
-      VKSCR(QueueSubmit)(screen->queue, num_si, submit, VK_NULL_HANDLE),
+      VKSCR(QueueSubmit)(bs->ctx->flags & PIPE_CONTEXT_VIDEO ? screen->queue_video_decode : screen->queue, num_si, submit, VK_NULL_HANDLE),
       if (result != VK_SUCCESS) {
          mesa_loge("ZINK: vkQueueSubmit failed (%s)", vk_Result_to_str(result));
          bs->is_device_lost = true;
@@ -790,14 +794,15 @@ submit_queue(void *data, void *gdata, int thread_index)
    );
    simple_mtx_unlock(&screen->queue_lock);
 
+   if (bs->copy_context_semaphore)
+      (void)util_dynarray_pop(&bs->signal_semaphores, VkSemaphore);
+
    unsigned i = 0;
    VkSemaphore *sem = bs->signal_semaphores.data;
    set_foreach(&bs->dmabuf_exports, entry) {
       struct zink_resource *res = (void*)entry->key;
       for (; res; res = zink_resource(res->base.b.next)) {
-         /* copy_context_semaphore is a special signal */
-         if (sem[i] != bs->copy_context_semaphore)
-            zink_screen_import_dmabuf_semaphore(screen, res, sem[i++]);
+         zink_screen_import_dmabuf_semaphore(screen, res, sem[i++]);
       }
 
       struct pipe_resource *pres = (void*)entry->key;
@@ -1209,8 +1214,8 @@ void
 zink_batch_sync_with_copy_context(struct zink_context *ctx)
 {
    struct zink_screen *screen = zink_screen(ctx->base.screen);
+   /* this gets temporarily appended to signal_semaphores during submit */
    screen->copy_context->bs->copy_context_semaphore = zink_create_semaphore(screen);
-   util_dynarray_append(&screen->copy_context->bs->signal_semaphores, VkSemaphore, screen->copy_context->bs->copy_context_semaphore);
    VkPipelineStageFlags flag = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    util_dynarray_append(&ctx->bs->wait_semaphores, VkSemaphore, screen->copy_context->bs->copy_context_semaphore);
    util_dynarray_append(&ctx->bs->wait_semaphore_stages, VkPipelineStageFlags, flag);
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 7be48b310f9d9..332de768a9865 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -3666,6 +3666,37 @@ zink_reset_ds3_states(struct zink_context *ctx)
       ctx->ds3_states &= ~BITFIELD_BIT(ZINK_DS3_RAST_STIPPLE);
 }
 
+static void
+reset_graphics_states(struct zink_context *ctx)
+{
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
+   if (screen->info.have_EXT_transform_feedback && ctx->num_so_targets)
+      ctx->dirty_so_targets = true;
+   ctx->pipeline_changed[0] = ctx->pipeline_changed[1] = true;
+   zink_select_draw_vbo(ctx);
+   zink_select_launch_grid(ctx);
+
+   if (ctx->oom_stall)
+      stall(ctx);
+   zink_reset_ds3_states(ctx);
+
+   ctx->oom_flush = false;
+   ctx->oom_stall = false;
+   ctx->dd.bindless_bound = false;
+   ctx->di.bindless_refs_dirty = true;
+   ctx->sample_locations_changed = ctx->gfx_pipeline_state.sample_locations_enabled;
+   if (screen->info.dynamic_state2_feats.extendedDynamicState2PatchControlPoints) {
+      VKCTX(CmdSetPatchControlPointsEXT)(ctx->bs->cmdbuf, ctx->gfx_pipeline_state.dyn_state2.vertices_per_patch);
+      VKCTX(CmdSetPatchControlPointsEXT)(ctx->bs->reordered_cmdbuf, 1);
+   }
+   update_feedback_loop_dynamic_state(ctx);
+   if (screen->info.have_EXT_color_write_enable)
+      reapply_color_write(ctx);
+   update_layered_rendering_state(ctx);
+   tc_renderpass_info_reset(&ctx->dynamic_fb.tc_info);
+   ctx->rp_tc_info_updated = true;
+}
+
 static void
 flush_batch(struct zink_context *ctx, bool sync)
 {
@@ -3686,33 +3717,9 @@ flush_batch(struct zink_context *ctx, bool sync)
    if (ctx->bs->is_device_lost) {
       check_device_lost(ctx);
    } else {
-      struct zink_screen *screen = zink_screen(ctx->base.screen);
       zink_start_batch(ctx);
-      if (screen->info.have_EXT_transform_feedback && ctx->num_so_targets)
-         ctx->dirty_so_targets = true;
-      ctx->pipeline_changed[0] = ctx->pipeline_changed[1] = true;
-      zink_select_draw_vbo(ctx);
-      zink_select_launch_grid(ctx);
-
-      if (ctx->oom_stall)
-         stall(ctx);
-      zink_reset_ds3_states(ctx);
-
-      ctx->oom_flush = false;
-      ctx->oom_stall = false;
-      ctx->dd.bindless_bound = false;
-      ctx->di.bindless_refs_dirty = true;
-      ctx->sample_locations_changed = ctx->gfx_pipeline_state.sample_locations_enabled;
-      if (zink_screen(ctx->base.screen)->info.dynamic_state2_feats.extendedDynamicState2PatchControlPoints) {
-         VKCTX(CmdSetPatchControlPointsEXT)(ctx->bs->cmdbuf, ctx->gfx_pipeline_state.dyn_state2.vertices_per_patch);
-         VKCTX(CmdSetPatchControlPointsEXT)(ctx->bs->reordered_cmdbuf, 1);
-      }
-      update_feedback_loop_dynamic_state(ctx);
-      if (screen->info.have_EXT_color_write_enable)
-         reapply_color_write(ctx);
-      update_layered_rendering_state(ctx);
-      tc_renderpass_info_reset(&ctx->dynamic_fb.tc_info);
-      ctx->rp_tc_info_updated = true;
+      if (!(ctx->flags & PIPE_CONTEXT_VIDEO))
+         reset_graphics_states(ctx);
    }
    util_queue_fence_signal(&ctx->flush_fence);
 }
@@ -5402,7 +5409,7 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
    struct zink_screen *screen = zink_screen(pscreen);
    struct zink_context *ctx = rzalloc(NULL, struct zink_context);
    bool is_copy_only = (flags & ZINK_CONTEXT_COPY_ONLY) > 0;
-   bool is_compute_only = (flags & PIPE_CONTEXT_COMPUTE_ONLY) > 0;
+   bool is_compute_only = (flags & (PIPE_CONTEXT_COMPUTE_ONLY | PIPE_CONTEXT_VIDEO)) > 0;
    bool is_robust = (flags & PIPE_CONTEXT_ROBUST_BUFFER_ACCESS) > 0;
    if (!ctx)
       goto fail;
diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 8b9a8011a8149..b93241e8c700f 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -2807,6 +2807,18 @@ zink_image_subdata(struct pipe_context *pctx,
    struct zink_resource *res = zink_resource(pres);
 
    res->subdata = true;
+   if (ctx->flags & PIPE_CONTEXT_VIDEO) {
+      /* video context only uses video queue and cannot access transfer ops */
+      zink_screen_lock_context(screen);
+      zink_image_subdata(&screen->copy_context->base, pres, level, usage, box, data, stride, layer_stride);
+      res->subdata = true;
+      /* add inter-context semaphore for synchronization */
+      zink_batch_sync_with_copy_context(ctx);
+      screen->copy_context->base.flush(&screen->copy_context->base, NULL, 0);
+      zink_screen_unlock_context(screen);
+      return;
+   }
+
    /* flush clears to avoid subdata conflict */
    if (!(usage & TC_TRANSFER_MAP_THREADED_UNSYNC) &&
        (res->obj->vkusage & VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT))
-- 
GitLab


From 5acc756d485980c1da585d412db339d796e4fb6a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Oct 2024 12:51:55 -0400
Subject: [PATCH 24/27] zink/video: use stream uploader

---
 src/gallium/drivers/zink/zink_video.c | 34 +++++++++++++++++----------
 src/gallium/drivers/zink/zink_video.h |  6 ++---
 2 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_video.c b/src/gallium/drivers/zink/zink_video.c
index a60b083129c2a..bc5c78d97495e 100644
--- a/src/gallium/drivers/zink/zink_video.c
+++ b/src/gallium/drivers/zink/zink_video.c
@@ -47,6 +47,12 @@
 #define DRM_FORMAT_MOD_LINEAR 0
 #endif
 
+static unsigned
+get_zvc_bitstream_size(struct zink_video_codec *zvc)
+{
+   return zvc->base.width * zvc->base.height * (512 / (16 * 16));
+}
+
 static void
 zink_destroy_video_codec(struct pipe_video_codec *codec) {
    struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
@@ -64,8 +70,8 @@ zink_destroy_video_codec(struct pipe_video_codec *codec) {
          }
       }
    }
-   for (unsigned i = 0; i < NUM_BUFFERS; i++)
-      pipe_resource_reference(&zvc->bs[i], NULL);
+   u_upload_unmap(zvc->bitstream_mgr);
+   u_upload_destroy(zvc->bitstream_mgr);
    for (unsigned i = 0; i < zvc->num_priv_mems; i++)
       zink_bo_unref(screen, zvc->priv_mems[i]);
 
@@ -226,8 +232,16 @@ zink_begin_frame(struct pipe_video_codec *codec,
                  struct pipe_picture_desc *picture)
 {
    struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
+   struct zink_context *ctx = zink_context(codec->context);
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
+   struct pipe_resource *bitstream_pres = NULL;
+   unsigned offset;
+   u_upload_alloc(zvc->bitstream_mgr, 0, get_zvc_bitstream_size(zvc),
+                  screen->info.props.limits.minMemoryMapAlignment, &offset,
+                  (struct pipe_resource **)&bitstream_pres, (void **)&zvc->bs_ptr);
+   zvc->bitstream_res = zink_resource(bitstream_pres);
    zvc->bs_size = 0;
-   zvc->bs_ptr = pipe_buffer_map(zvc->base.context, zvc->bs[zvc->cur_bs_buf], PIPE_MAP_WRITE, &zvc->bs_xfer);
+   zink_batch_reference_resource_rw(ctx, zvc->bitstream_res, true);
 
    if (!zvc->session)
       zink_video_create_session(zvc, codec->width, codec->height,
@@ -365,7 +379,7 @@ static void
 end_bitstream(struct zink_video_codec *zvc)
 {
    zvc->bs_ptr = NULL;
-   pipe_buffer_unmap(zvc->base.context, zvc->bs_xfer);
+   u_upload_unmap(zvc->bitstream_mgr);
 }
 
 static void
@@ -378,7 +392,7 @@ end_coding(struct zink_screen *screen,
 
    VKSCR(CmdEndVideoCodingKHR)(cmdbuf, &eci);
 
-   struct zink_resource *zbs = (struct zink_resource *)zvc->bs[zvc->cur_bs_buf];
+   struct zink_resource *zbs = zvc->bitstream_res;
    VkBufferMemoryBarrier2KHR bitstream_bmb;
    bitstream_bmb.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR;
    bitstream_bmb.pNext = NULL;
@@ -422,8 +436,6 @@ end_coding(struct zink_screen *screen,
    VKSCR(DestroyVideoSessionParametersKHR)(screen->dev,
                                            zvc->params, NULL);
 
-   zvc->cur_bs_buf++;
-   zvc->cur_bs_buf %= NUM_BUFFERS;
 }
 
 static int
@@ -578,7 +590,7 @@ zink_end_frame_h264(struct pipe_video_codec *codec,
       zvc->reset_sent = true;
    }
 
-   struct zink_resource *zbs = (struct zink_resource *)zvc->bs[zvc->cur_bs_buf];
+   struct zink_resource *zbs = zvc->bitstream_res;
    VkBufferMemoryBarrier2KHR bitstream_bmb;
    bitstream_bmb.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR;
    bitstream_bmb.pNext = NULL;
@@ -663,17 +675,13 @@ zink_create_video_codec(struct pipe_context *pctx, const struct pipe_video_codec
    zvc->base.context = pctx;
 
    zvc->screen = pctx->screen;
+   zvc->bitstream_mgr = u_upload_create(pctx, get_zvc_bitstream_size(zvc), ZINK_BIND_VIDEO, PIPE_USAGE_STAGING, 0);
 
    VkCommandPoolCreateInfo cpci = {0};
    cpci.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    cpci.queueFamilyIndex = screen->video_decode_queue;
    if (VKSCR(CreateCommandPool)(screen->dev, &cpci, NULL, &zvc->cmdpool) != VK_SUCCESS)
       return NULL;
-
-   for (unsigned i = 0; i < NUM_BUFFERS; i++) {
-      zvc->bs[i] = pipe_buffer_create(&screen->base, ZINK_BIND_VIDEO, PIPE_USAGE_STAGING,
-                                      zvc->base.width * zvc->base.height * (512 / (16 * 16)));
-   }
    return &zvc->base;
 }
 
diff --git a/src/gallium/drivers/zink/zink_video.h b/src/gallium/drivers/zink/zink_video.h
index ca97ce358d734..b9615fc007c18 100644
--- a/src/gallium/drivers/zink/zink_video.h
+++ b/src/gallium/drivers/zink/zink_video.h
@@ -30,6 +30,7 @@
 #define ZINK_VIDEO_H
 
 #include "pipe/p_video_codec.h"
+#include "util/u_upload_mgr.h"
 #include "zink_types.h"
 
 #define NUM_BUFFERS 4
@@ -39,11 +40,10 @@ struct zink_video_codec {
    struct pipe_screen *screen;
    void *bs_ptr;
    size_t bs_size;
-   struct pipe_transfer *bs_xfer;
    VkCommandPool cmdpool;
+   struct u_upload_mgr *bitstream_mgr;
+   struct zink_resource *bitstream_res;
    VkVideoSessionParametersKHR params;
-   struct pipe_resource *bs[NUM_BUFFERS];
-   unsigned cur_bs_buf;
    unsigned num_priv_mems;
    unsigned max_dpb_slots;
    struct zink_bo **priv_mems;
-- 
GitLab


From b491bc708bf1a9fa63698319f228d9eec654eb81 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Oct 2024 12:52:42 -0400
Subject: [PATCH 25/27] zink/video: use regular zink batches

perf+++++++
---
 src/gallium/drivers/zink/zink_batch.c |  4 ++
 src/gallium/drivers/zink/zink_types.h |  2 +
 src/gallium/drivers/zink/zink_video.c | 62 ++++++++-------------------
 src/gallium/drivers/zink/zink_video.h |  1 -
 4 files changed, 23 insertions(+), 46 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_batch.c b/src/gallium/drivers/zink/zink_batch.c
index 6ef7b68ebb119..427c19e2bd142 100644
--- a/src/gallium/drivers/zink/zink_batch.c
+++ b/src/gallium/drivers/zink/zink_batch.c
@@ -110,6 +110,10 @@ reset_batch_state_internal(struct zink_screen *screen, struct zink_batch_state *
       zink_program_reference(screen, &pg, NULL);
    }
 
+   if (bs->video_params)
+      VKSCR(DestroyVideoSessionParametersKHR)(screen->dev, bs->video_params, NULL);
+   bs->video_params = VK_NULL_HANDLE;
+
    bs->resource_size = 0;
    bs->signal_semaphore = VK_NULL_HANDLE;
    bs->sparse_semaphore = VK_NULL_HANDLE;
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index 6e441a0fdbfdb..bb80ef0863bc6 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -615,6 +615,8 @@ struct zink_batch_state {
    VkSemaphore sparse_semaphore; //current sparse wait semaphore
    struct util_dynarray fences; //zink_tc_fence refs
 
+   VkVideoSessionParametersKHR video_params;
+
    VkSemaphore present;
    struct zink_resource *swapchain;
    struct util_dynarray acquires;
diff --git a/src/gallium/drivers/zink/zink_video.c b/src/gallium/drivers/zink/zink_video.c
index bc5c78d97495e..ae2d6ef510fd7 100644
--- a/src/gallium/drivers/zink/zink_video.c
+++ b/src/gallium/drivers/zink/zink_video.c
@@ -81,7 +81,6 @@ zink_destroy_video_codec(struct pipe_video_codec *codec) {
    }
    /* ensure session is no longer in use */
    VKSCR(QueueWaitIdle)(screen->queue_video_decode);
-   VKSCR(DestroyCommandPool)(screen->dev, zvc->cmdpool, NULL);
    VKSCR(DestroyVideoSessionKHR)(screen->dev,
                                  zvc->session, NULL);
    free(zvc);
@@ -248,6 +247,14 @@ zink_begin_frame(struct pipe_video_codec *codec,
                                 target->buffer_format,
                                 codec->profile, codec->entrypoint);
 
+   if (zvc->dpb_array) {
+      zink_batch_reference_resource_rw(ctx, zink_resource(zvc->dpb_res[0]), true);
+   } else {
+      for (unsigned i = 0; i < zvc->max_dpb_slots; i++) {
+         if (zvc->dpb_res[i])
+            zink_batch_reference_resource_rw(ctx, zink_resource(zvc->dpb_res[i]), true);
+      }
+   }
 }
 
 static void
@@ -383,14 +390,14 @@ end_bitstream(struct zink_video_codec *zvc)
 }
 
 static void
-end_coding(struct zink_screen *screen,
+end_coding(struct zink_context *ctx,
            struct zink_video_codec *zvc,
            VkCommandBuffer cmdbuf)
 {
    VkVideoEndCodingInfoKHR eci = { 0 };
    eci.sType = VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR;
 
-   VKSCR(CmdEndVideoCodingKHR)(cmdbuf, &eci);
+   VKCTX(CmdEndVideoCodingKHR)(cmdbuf, &eci);
 
    struct zink_resource *zbs = zvc->bitstream_res;
    VkBufferMemoryBarrier2KHR bitstream_bmb;
@@ -413,29 +420,11 @@ end_coding(struct zink_screen *screen,
    di.bufferMemoryBarrierCount = 1;
    di.pBufferMemoryBarriers = &bitstream_bmb;
    /* TODO image barriers */
-   VKSCR(CmdPipelineBarrier2KHR)(cmdbuf, &di);
-
-   if (VKSCR(EndCommandBuffer)(cmdbuf) != VK_SUCCESS) {
-      debug_printf("vkEndCommandBuffer failed\n");
-   }
-
-   VkSubmitInfo si = {0};
-   si.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
-   si.waitSemaphoreCount = 0;
-   si.pWaitSemaphores = NULL;
-   si.signalSemaphoreCount = 0;
-   si.pSignalSemaphores = NULL;
-   VkPipelineStageFlags videoDecodeSubmitWaitStages = VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
-   si.pWaitDstStageMask = &videoDecodeSubmitWaitStages;
-   si.commandBufferCount = 1;
-   si.pCommandBuffers = &cmdbuf;
-
-   VKSCR(QueueSubmit)(screen->queue_video_decode, 1, &si, NULL);
-   VKSCR(QueueWaitIdle)(screen->queue_video_decode);
-   VKSCR(FreeCommandBuffers)(screen->dev, zvc->cmdpool, 1, &cmdbuf);
-   VKSCR(DestroyVideoSessionParametersKHR)(screen->dev,
-                                           zvc->params, NULL);
+   VKCTX(CmdPipelineBarrier2KHR)(cmdbuf, &di);
 
+   ctx->bs->video_params = zvc->params;
+   ctx->bs->has_work = true;
+   ctx->base.flush(&ctx->base, NULL, 0);
 }
 
 static int
@@ -444,6 +433,7 @@ zink_end_frame_h264(struct pipe_video_codec *codec,
                     struct pipe_picture_desc *picture)
 {
    struct zink_video_codec *zvc = (struct zink_video_codec *)codec;
+   struct zink_context *ctx = zink_context(codec->context);
    struct zink_screen *screen = (struct zink_screen *)zvc->screen;
    struct pipe_h264_picture_desc *h264 = (struct pipe_h264_picture_desc *)picture;
 
@@ -559,19 +549,7 @@ zink_end_frame_h264(struct pipe_video_codec *codec,
 
    VKSCR(CreateVideoSessionParametersKHR)(screen->dev, &pci, NULL, &zvc->params);
 
-   VkCommandBuffer cmdbuf;
-   VkCommandBufferAllocateInfo cbai = {0};
-   cbai.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
-   cbai.commandPool = zvc->cmdpool;
-   cbai.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
-   cbai.commandBufferCount = 1;
-
-   VKSCR(AllocateCommandBuffers)(screen->dev, &cbai, &cmdbuf);
-
-   VkCommandBufferBeginInfo cbbi = {0};
-   cbbi.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
-   cbbi.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
-   VKSCR(BeginCommandBuffer)(cmdbuf, &cbbi);
+   VkCommandBuffer cmdbuf = ctx->bs->cmdbuf;
 
    VkVideoBeginCodingInfoKHR bci = { 0 };
    bci.sType = VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR;
@@ -647,7 +625,7 @@ zink_end_frame_h264(struct pipe_video_codec *codec,
    vdi.srcBufferRange = align64(zvc->bs_size, zvc->srcbuf_align);
    VKSCR(CmdDecodeVideoKHR)(cmdbuf, &vdi);
 
-   end_coding(screen, zvc, cmdbuf);
+   end_coding(ctx, zvc, cmdbuf);
 
    return 0;
 }
@@ -659,7 +637,6 @@ zink_video_flush(struct pipe_video_codec *codec) {
 static struct pipe_video_codec *
 zink_create_video_codec(struct pipe_context *pctx, const struct pipe_video_codec *templat)
 {
-   struct zink_screen *screen = zink_screen(pctx->screen);
    struct zink_video_codec *zvc = CALLOC_STRUCT(zink_video_codec);
    if (!zvc) {
       return NULL;
@@ -677,11 +654,6 @@ zink_create_video_codec(struct pipe_context *pctx, const struct pipe_video_codec
    zvc->screen = pctx->screen;
    zvc->bitstream_mgr = u_upload_create(pctx, get_zvc_bitstream_size(zvc), ZINK_BIND_VIDEO, PIPE_USAGE_STAGING, 0);
 
-   VkCommandPoolCreateInfo cpci = {0};
-   cpci.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
-   cpci.queueFamilyIndex = screen->video_decode_queue;
-   if (VKSCR(CreateCommandPool)(screen->dev, &cpci, NULL, &zvc->cmdpool) != VK_SUCCESS)
-      return NULL;
    return &zvc->base;
 }
 
diff --git a/src/gallium/drivers/zink/zink_video.h b/src/gallium/drivers/zink/zink_video.h
index b9615fc007c18..ffe4a550c8231 100644
--- a/src/gallium/drivers/zink/zink_video.h
+++ b/src/gallium/drivers/zink/zink_video.h
@@ -40,7 +40,6 @@ struct zink_video_codec {
    struct pipe_screen *screen;
    void *bs_ptr;
    size_t bs_size;
-   VkCommandPool cmdpool;
    struct u_upload_mgr *bitstream_mgr;
    struct zink_resource *bitstream_res;
    VkVideoSessionParametersKHR params;
-- 
GitLab


From f35f6b972f3db96c08162e4eefc61149bde3da66 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Oct 2024 12:54:59 -0400
Subject: [PATCH 26/27] zink/video: add a big juicy hack to fix possible
 implicit sync bug

seems to only trigger if bitrate is high enough?
---
 src/gallium/drivers/zink/zink_batch.c  | 3 +++
 src/gallium/drivers/zink/zink_kopper.c | 3 +++
 src/gallium/drivers/zink/zink_types.h  | 2 ++
 3 files changed, 8 insertions(+)

diff --git a/src/gallium/drivers/zink/zink_batch.c b/src/gallium/drivers/zink/zink_batch.c
index 427c19e2bd142..88e5287b937e9 100644
--- a/src/gallium/drivers/zink/zink_batch.c
+++ b/src/gallium/drivers/zink/zink_batch.c
@@ -796,6 +796,9 @@ submit_queue(void *data, void *gdata, int thread_index)
          bs->is_device_lost = true;
       }
    );
+   /* FIXME: delet this */
+   if (bs->ctx->flags & PIPE_CONTEXT_VIDEO)
+      screen->VIDEO_PRESENT_HACK = true;
    simple_mtx_unlock(&screen->queue_lock);
 
    if (bs->copy_context_semaphore)
diff --git a/src/gallium/drivers/zink/zink_kopper.c b/src/gallium/drivers/zink/zink_kopper.c
index f96d693eef2bc..d4374257e1de3 100644
--- a/src/gallium/drivers/zink/zink_kopper.c
+++ b/src/gallium/drivers/zink/zink_kopper.c
@@ -771,6 +771,9 @@ kopper_present(void *data, void *gdata, int thread_idx)
       cpi->info.pWaitSemaphores = NULL;
       cpi->info.waitSemaphoreCount = 0;
    }
+   /* FIXME: delet this */
+   if (screen->VIDEO_PRESENT_HACK)
+      VKSCR(QueueWaitIdle)(screen->queue);
    VkResult error2 = VKSCR(QueuePresentKHR)(screen->queue, &cpi->info);
    zink_screen_debug_marker_end(screen, screen->frame_marker_emitted);
    zink_screen_debug_marker_begin(screen, "frame");
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index bb80ef0863bc6..04ee42d7c05ae 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -1357,6 +1357,8 @@ struct zink_screen {
    PFN_vkGetInstanceProcAddr vk_GetInstanceProcAddr;
    PFN_vkGetDeviceProcAddr vk_GetDeviceProcAddr;
 
+   /* FIXME: delet this */
+   bool VIDEO_PRESENT_HACK; //somehow implicit sync is broken with video decode on anv?
    bool threaded;
    bool threaded_submit;
    bool is_cpu;
-- 
GitLab


From 4ded30f042e085babb2e1a66973712bcdc079a59 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 25 Oct 2024 08:13:12 -0400
Subject: [PATCH 27/27] zink/video: don't store video codec to video buffer

the codec may be destroyed before the buffer, so accessing this is invalid

also it shouldn't ever be the case that a buffer is reused across codecs?
---
 src/gallium/drivers/zink/zink_video.c | 10 ++--------
 src/gallium/drivers/zink/zink_video.h |  2 +-
 2 files changed, 3 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_video.c b/src/gallium/drivers/zink/zink_video.c
index ae2d6ef510fd7..0a82196d1a5a2 100644
--- a/src/gallium/drivers/zink/zink_video.c
+++ b/src/gallium/drivers/zink/zink_video.c
@@ -90,15 +90,9 @@ static void
 zink_destroy_associated_data(void *data)
 {
    struct zink_video_surf_data *surf = data;
-   struct zink_video_codec *zvc = (struct zink_video_codec *)surf->codec;
-   struct zink_screen *screen = (struct zink_screen *)zvc->screen;
+   struct zink_screen *screen = surf->screen;
    VKSCR(DestroyImageView)(screen->dev, surf->resource.imageViewBinding, NULL);
 
-   for (unsigned i = 0; i < zvc->max_dpb_slots; i++) {
-      if (zvc->render_pic_list[i] == data) {
-         zvc->render_pic_list[i] = NULL;
-      }
-   }
    /* destroy iv */
    free(surf);
 }
@@ -364,7 +358,7 @@ create_surf(struct zink_video_codec *zvc,
    struct zink_screen *screen = (struct zink_screen *)zvc->screen;
    struct zink_video_surf_data *surf = calloc(sizeof(*surf), 1);
 
-   surf->codec = zvc;
+   surf->screen = screen;
    surf->resource.sType = VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
    surf->resource.pNext = NULL;
    surf->resource.codedExtent.width = target->width;
diff --git a/src/gallium/drivers/zink/zink_video.h b/src/gallium/drivers/zink/zink_video.h
index ffe4a550c8231..1ca8c2d05bd60 100644
--- a/src/gallium/drivers/zink/zink_video.h
+++ b/src/gallium/drivers/zink/zink_video.h
@@ -59,7 +59,7 @@ struct zink_video_codec {
 
 struct zink_video_surf_data {
    VkVideoPictureResourceInfoKHR resource;
-   struct zink_video_codec *codec;
+   struct zink_screen *screen;
    uint32_t dpb_index;
 };
 
-- 
GitLab

