From d738a231fcbdb8b6317eb1fa91519f43651b53b4 Mon Sep 17 00:00:00 2001
From: Kenneth Graunke <kenneth@whitecape.org>
Date: Wed, 8 Feb 2023 13:00:49 +1000
Subject: [PATCH 01/20] hasvk: Make a batch decoder for each queue family

The decoder context needs to know what engine it's associated with.
Nowadays, we have render, compute, blitter, even video engines being
used from the same driver.  Rather than trying to have a single decoder
and thwacking the engine field back and forth between calls, we make
one per queue family, and stash a pointer in anv_queue for easy access.

(Ported from anv: 79caf8a44b682f731c0fd3b941f38cc1869efe2d)
---
 src/intel/vulkan_hasvk/anv_batch_chain.c |  8 ++---
 src/intel/vulkan_hasvk/anv_device.c      | 44 ++++++++++++++----------
 src/intel/vulkan_hasvk/anv_private.h     |  4 ++-
 src/intel/vulkan_hasvk/anv_queue.c       |  2 ++
 4 files changed, 35 insertions(+), 23 deletions(-)

diff --git a/src/intel/vulkan_hasvk/anv_batch_chain.c b/src/intel/vulkan_hasvk/anv_batch_chain.c
index a13c1670c63f9..a3369a1064253 100644
--- a/src/intel/vulkan_hasvk/anv_batch_chain.c
+++ b/src/intel/vulkan_hasvk/anv_batch_chain.c
@@ -2171,7 +2171,7 @@ anv_queue_exec_locked(struct anv_queue *queue,
             uint64_t pass_batch_offset =
                khr_perf_query_preamble_offset(perf_query_pool, perf_query_pass);
 
-            intel_print_batch(&device->decoder_ctx,
+            intel_print_batch(queue->decoder,
                               pass_batch_bo->map + pass_batch_offset, 64,
                               pass_batch_bo->offset + pass_batch_offset, false);
          }
@@ -2180,12 +2180,12 @@ anv_queue_exec_locked(struct anv_queue *queue,
             struct anv_batch_bo **bo =
                u_vector_tail(&cmd_buffers[i]->seen_bbos);
             device->cmd_buffer_being_decoded = cmd_buffers[i];
-            intel_print_batch(&device->decoder_ctx, (*bo)->bo->map,
+            intel_print_batch(queue->decoder, (*bo)->bo->map,
                               (*bo)->bo->size, (*bo)->bo->offset, false);
             device->cmd_buffer_being_decoded = NULL;
          }
       } else {
-         intel_print_batch(&device->decoder_ctx,
+         intel_print_batch(queue->decoder,
                            device->trivial_batch_bo->map,
                            device->trivial_batch_bo->size,
                            device->trivial_batch_bo->offset, false);
@@ -2434,7 +2434,7 @@ anv_queue_submit_simple_batch(struct anv_queue *queue,
       goto fail;
 
    if (INTEL_DEBUG(DEBUG_BATCH)) {
-      intel_print_batch(&device->decoder_ctx,
+      intel_print_batch(queue->decoder,
                         batch_bo->map,
                         batch_bo->size,
                         batch_bo->offset, false);
diff --git a/src/intel/vulkan_hasvk/anv_device.c b/src/intel/vulkan_hasvk/anv_device.c
index 5775a0dd60f59..3bf2b8dd89b7c 100644
--- a/src/intel/vulkan_hasvk/anv_device.c
+++ b/src/intel/vulkan_hasvk/anv_device.c
@@ -2729,22 +2729,26 @@ VkResult anv_CreateDevice(
       goto fail_alloc;
 
    if (INTEL_DEBUG(DEBUG_BATCH)) {
-      const unsigned decode_flags =
-         INTEL_BATCH_DECODE_FULL |
-         (INTEL_DEBUG(DEBUG_COLOR) ? INTEL_BATCH_DECODE_IN_COLOR : 0) |
-         INTEL_BATCH_DECODE_OFFSETS |
-         INTEL_BATCH_DECODE_FLOATS;
-
-      intel_batch_decode_ctx_init(&device->decoder_ctx,
-                                  &physical_device->compiler->isa,
-                                  &physical_device->info,
-                                  stderr, decode_flags, NULL,
-                                  decode_get_bo, NULL, device);
-
-      device->decoder_ctx.dynamic_base = DYNAMIC_STATE_POOL_MIN_ADDRESS;
-      device->decoder_ctx.surface_base = SURFACE_STATE_POOL_MIN_ADDRESS;
-      device->decoder_ctx.instruction_base =
-         INSTRUCTION_STATE_POOL_MIN_ADDRESS;
+      for (unsigned i = 0; i < physical_device->queue.family_count; i++) {
+         struct intel_batch_decode_ctx *decoder = &device->decoder[i];
+
+         const unsigned decode_flags =
+            INTEL_BATCH_DECODE_FULL |
+            (INTEL_DEBUG(DEBUG_COLOR) ? INTEL_BATCH_DECODE_IN_COLOR : 0) |
+            INTEL_BATCH_DECODE_OFFSETS |
+            INTEL_BATCH_DECODE_FLOATS;
+
+         intel_batch_decode_ctx_init(decoder,
+                                     &physical_device->compiler->isa,
+                                     &physical_device->info,
+                                     stderr, decode_flags, NULL,
+                                     decode_get_bo, NULL, device);
+
+         decoder->engine = physical_device->queue.families[i].engine_class;
+         decoder->dynamic_base = DYNAMIC_STATE_POOL_MIN_ADDRESS;
+         decoder->surface_base = SURFACE_STATE_POOL_MIN_ADDRESS;
+         decoder->instruction_base = INSTRUCTION_STATE_POOL_MIN_ADDRESS;
+      }
    }
 
    anv_device_set_physical(device, physical_device);
@@ -3047,6 +3051,8 @@ void anv_DestroyDevice(
    if (!device)
       return;
 
+   struct anv_physical_device *pdevice = device->physical;
+
    anv_device_utrace_finish(device);
 
    anv_device_finish_blorp(device);
@@ -3095,8 +3101,10 @@ void anv_DestroyDevice(
 
    intel_gem_destroy_context(device->fd, device->context_id);
 
-   if (INTEL_DEBUG(DEBUG_BATCH))
-      intel_batch_decode_ctx_finish(&device->decoder_ctx);
+   if (INTEL_DEBUG(DEBUG_BATCH)) {
+      for (unsigned i = 0; i < pdevice->queue.family_count; i++)
+         intel_batch_decode_ctx_finish(&device->decoder[i]);
+   }
 
    close(device->fd);
 
diff --git a/src/intel/vulkan_hasvk/anv_private.h b/src/intel/vulkan_hasvk/anv_private.h
index 73c0c8605844b..05deaa0539cbe 100644
--- a/src/intel/vulkan_hasvk/anv_private.h
+++ b/src/intel/vulkan_hasvk/anv_private.h
@@ -970,6 +970,8 @@ struct anv_queue {
 
    const struct anv_queue_family *           family;
 
+   struct intel_batch_decode_ctx *           decoder;
+
    uint32_t                                  exec_flags;
 
    /** Synchronization object for debug purposes (DEBUG_SYNC) */
@@ -1087,7 +1089,7 @@ struct anv_device {
     pthread_mutex_t                             mutex;
     pthread_cond_t                              queue_submit;
 
-    struct intel_batch_decode_ctx               decoder_ctx;
+    struct intel_batch_decode_ctx               decoder[ANV_MAX_QUEUE_FAMILIES];
     /*
      * When decoding a anv_cmd_buffer, we might need to search for BOs through
      * the cmd_buffer's list.
diff --git a/src/intel/vulkan_hasvk/anv_queue.c b/src/intel/vulkan_hasvk/anv_queue.c
index d3999434422ce..1101c90397568 100644
--- a/src/intel/vulkan_hasvk/anv_queue.c
+++ b/src/intel/vulkan_hasvk/anv_queue.c
@@ -59,6 +59,8 @@ anv_queue_init(struct anv_device *device, struct anv_queue *queue,
    queue->family = &pdevice->queue.families[queue->vk.queue_family_index];
    queue->exec_flags = exec_flags;
 
+   queue->decoder = &device->decoder[queue->vk.queue_family_index];
+
    return VK_SUCCESS;
 }
 
-- 
GitLab


From 3046a747c2ae42448617a69fafcc6eec97830ec8 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:25:30 +1000
Subject: [PATCH 02/20] hasvk: add video engine support in various places

---
 src/intel/vulkan_hasvk/anv_device.c      | 20 +++++++++--
 src/intel/vulkan_hasvk/genX_cmd_buffer.c | 42 ++++++++++++++++++++++++
 src/intel/vulkan_hasvk/genX_state.c      |  3 ++
 3 files changed, 63 insertions(+), 2 deletions(-)

diff --git a/src/intel/vulkan_hasvk/anv_device.c b/src/intel/vulkan_hasvk/anv_device.c
index 3bf2b8dd89b7c..b5b31303495ac 100644
--- a/src/intel/vulkan_hasvk/anv_device.c
+++ b/src/intel/vulkan_hasvk/anv_device.c
@@ -542,6 +542,7 @@ anv_physical_device_free_disk_cache(struct anv_physical_device *device)
  *  * "gc" is for graphics queues with compute support
  *  * "g" is for graphics queues with no compute support
  *  * "c" is for compute queues with no graphics support
+ *  * "v" is for video queues with no graphics support
  *
  * For example, ANV_QUEUE_OVERRIDE=gc=2,c=1 would override the number of
  * advertised queues to be 2 queues with graphics+compute support, and 1 queue
@@ -556,11 +557,12 @@ anv_physical_device_free_disk_cache(struct anv_physical_device *device)
  * number of graphics+compute queues to be 0.
  */
 static void
-anv_override_engine_counts(int *gc_count, int *g_count, int *c_count)
+anv_override_engine_counts(int *gc_count, int *g_count, int *c_count, int *v_count)
 {
    int gc_override = -1;
    int g_override = -1;
    int c_override = -1;
+   int v_override = -1;
    char *env = getenv("ANV_QUEUE_OVERRIDE");
 
    if (env == NULL)
@@ -576,6 +578,8 @@ anv_override_engine_counts(int *gc_count, int *g_count, int *c_count)
          g_override = strtol(next + 2, NULL, 0);
       } else if (strncmp(next, "c=", 2) == 0) {
          c_override = strtol(next + 2, NULL, 0);
+      } else if (strncmp(next, "v=", 2) == 0) {
+         v_override = strtol(next + 2, NULL, 0);
       } else {
          mesa_logw("Ignoring unsupported ANV_QUEUE_OVERRIDE token: %s", next);
       }
@@ -591,6 +595,8 @@ anv_override_engine_counts(int *gc_count, int *g_count, int *c_count)
                 "Vulkan specification");
    if (c_override >= 0)
       *c_count = c_override;
+   if (v_override >= 0)
+      *v_count = v_override;
 }
 
 static void
@@ -602,10 +608,13 @@ anv_physical_device_init_queue_families(struct anv_physical_device *pdevice)
       int gc_count =
          intel_engines_count(pdevice->engine_info,
                              INTEL_ENGINE_CLASS_RENDER);
+      int v_count =
+         intel_engines_count(pdevice->engine_info,
+                             I915_ENGINE_CLASS_VIDEO);
       int g_count = 0;
       int c_count = 0;
 
-      anv_override_engine_counts(&gc_count, &g_count, &c_count);
+      anv_override_engine_counts(&gc_count, &g_count, &c_count, &v_count);
 
       if (gc_count > 0) {
          pdevice->queue.families[family_count++] = (struct anv_queue_family) {
@@ -632,6 +641,13 @@ anv_physical_device_init_queue_families(struct anv_physical_device *pdevice)
             .engine_class = INTEL_ENGINE_CLASS_RENDER,
          };
       }
+      if (v_count > 0) {
+         pdevice->queue.families[family_count++] = (struct anv_queue_family) {
+            .queueFlags = VK_QUEUE_VIDEO_DECODE_BIT_KHR,
+            .queueCount = v_count,
+            .engine_class = I915_ENGINE_CLASS_VIDEO,
+         };
+      }
       /* Increase count below when other families are added as a reminder to
        * increase the ANV_MAX_QUEUE_FAMILIES value.
        */
diff --git a/src/intel/vulkan_hasvk/genX_cmd_buffer.c b/src/intel/vulkan_hasvk/genX_cmd_buffer.c
index ac0118390ba7c..106b5e967439c 100644
--- a/src/intel/vulkan_hasvk/genX_cmd_buffer.c
+++ b/src/intel/vulkan_hasvk/genX_cmd_buffer.c
@@ -86,6 +86,13 @@ is_render_queue_cmd_buffer(const struct anv_cmd_buffer *cmd_buffer)
    return (queue_family->queueFlags & VK_QUEUE_GRAPHICS_BIT) != 0;
 }
 
+static bool
+is_video_queue_cmd_buffer(const struct anv_cmd_buffer *cmd_buffer)
+{
+   struct anv_queue_family *queue_family = cmd_buffer->queue_family;
+   return (queue_family->queueFlags & VK_QUEUE_VIDEO_DECODE_BIT_KHR) != 0;
+}
+
 void
 genX(cmd_buffer_emit_state_base_address)(struct anv_cmd_buffer *cmd_buffer)
 {
@@ -1311,6 +1318,9 @@ genX(BeginCommandBuffer)(
    if (cmd_buffer->vk.level == VK_COMMAND_BUFFER_LEVEL_PRIMARY)
       cmd_buffer->usage_flags &= ~VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;
 
+   if (is_video_queue_cmd_buffer(cmd_buffer))
+      return VK_SUCCESS;
+
    trace_intel_begin_cmd_buffer(&cmd_buffer->trace);
 
    genX(cmd_buffer_emit_state_base_address)(cmd_buffer);
@@ -1471,6 +1481,11 @@ genX(EndCommandBuffer)(
    if (anv_batch_has_error(&cmd_buffer->batch))
       return cmd_buffer->batch.status;
 
+   if (is_video_queue_cmd_buffer(cmd_buffer)) {
+      anv_cmd_buffer_end_batch_buffer(cmd_buffer);
+      return VK_SUCCESS;
+   }
+
    anv_measure_endcommandbuffer(cmd_buffer);
 
    /* We want every command buffer to start with the PMA fix in a known state,
@@ -1928,6 +1943,9 @@ cmd_buffer_barrier(struct anv_cmd_buffer *cmd_buffer,
    VkAccessFlags2 src_flags = 0;
    VkAccessFlags2 dst_flags = 0;
 
+   if (is_video_queue_cmd_buffer(cmd_buffer))
+      return;
+
    for (uint32_t i = 0; i < dep_info->memoryBarrierCount; i++) {
       src_flags |= dep_info->pMemoryBarriers[i].srcAccessMask;
       dst_flags |= dep_info->pMemoryBarriers[i].dstAccessMask;
@@ -5849,6 +5867,18 @@ void genX(CmdSetEvent2)(
    ANV_FROM_HANDLE(anv_cmd_buffer, cmd_buffer, commandBuffer);
    ANV_FROM_HANDLE(anv_event, event, _event);
 
+   if (is_video_queue_cmd_buffer(cmd_buffer)) {
+      anv_batch_emit(&cmd_buffer->batch, GENX(MI_FLUSH_DW), flush) {
+         flush.PostSyncOperation = WriteImmediateData;
+         flush.Address = (struct anv_address) {
+            cmd_buffer->device->dynamic_state_pool.block_pool.bo,
+            event->state.offset
+         };
+         flush.ImmediateData = VK_EVENT_SET;
+      }
+      return;
+   }
+
    VkPipelineStageFlags2 src_stages = 0;
 
    for (uint32_t i = 0; i < pDependencyInfo->memoryBarrierCount; i++)
@@ -5886,6 +5916,18 @@ void genX(CmdResetEvent2)(
    ANV_FROM_HANDLE(anv_cmd_buffer, cmd_buffer, commandBuffer);
    ANV_FROM_HANDLE(anv_event, event, _event);
 
+   if (is_video_queue_cmd_buffer(cmd_buffer)) {
+      anv_batch_emit(&cmd_buffer->batch, GENX(MI_FLUSH_DW), flush) {
+         flush.PostSyncOperation = WriteImmediateData;
+         flush.Address = (struct anv_address) {
+            cmd_buffer->device->dynamic_state_pool.block_pool.bo,
+            event->state.offset
+         };
+         flush.ImmediateData = VK_EVENT_RESET;
+      }
+      return;
+   }
+
    cmd_buffer->state.pending_pipe_bits |= ANV_PIPE_POST_SYNC_BIT;
    genX(cmd_buffer_apply_pipe_flushes)(cmd_buffer);
 
diff --git a/src/intel/vulkan_hasvk/genX_state.c b/src/intel/vulkan_hasvk/genX_state.c
index 649d65bbdc0ee..106533994b4e4 100644
--- a/src/intel/vulkan_hasvk/genX_state.c
+++ b/src/intel/vulkan_hasvk/genX_state.c
@@ -119,6 +119,9 @@ genX(init_device_state)(struct anv_device *device)
       case INTEL_ENGINE_CLASS_RENDER:
          res = init_render_queue_state(queue);
          break;
+      case INTEL_ENGINE_CLASS_VIDEO:
+         res = VK_SUCCESS;
+         break;
       default:
          res = vk_error(device, VK_ERROR_INITIALIZATION_FAILED);
          break;
-- 
GitLab


From 3773da9b8aefdf6ea4355dba7779d9cd8e18cc7e Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:26:06 +1000
Subject: [PATCH 03/20] intel/genxml: some video related genxml updates for
 hasvk

---
 src/intel/genxml/gen7.xml  | 8 +++-----
 src/intel/genxml/gen75.xml | 8 +++-----
 src/intel/genxml/gen8.xml  | 4 ++--
 3 files changed, 8 insertions(+), 12 deletions(-)

diff --git a/src/intel/genxml/gen7.xml b/src/intel/genxml/gen7.xml
index 380d20cc68b9b..e8d4573bc7c71 100644
--- a/src/intel/genxml/gen7.xml
+++ b/src/intel/genxml/gen7.xml
@@ -1966,7 +1966,7 @@
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
     <field name="Indirect BSD Data Length" start="32" end="63" type="uint" />
-    <field name="Indirect BSD Data Start Address" start="64" end="92" type="address" />
+    <field name="Indirect BSD Data Start Address" start="64" end="92" type="offset" />
     <field name="Inline Data" start="96" end="191" type="INLINE_DATA_DESCRIPTION_FOR_MFD_AVC_BSD_OBJECT" />
   </instruction>
   <instruction name="MFD_AVC_DPB_STATE" bias="2" length="11" engine="video">
@@ -2008,7 +2008,7 @@
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
     <field name="Indirect BSD Data Length" start="32" end="63" type="uint" />
-    <field name="Indirect BSD Data Start Address" start="64" end="92" type="address" />
+    <field name="Indirect BSD Data Start Address" start="64" end="92" type="offset" />
   </instruction>
   <instruction name="MFD_IT_OBJECT" bias="2" engine="video">
     <field name="DWord Length" start="0" end="11" type="uint" default="6" />
@@ -3208,9 +3208,7 @@
       <value name="GGTT" value="1" />
     </field>
     <field name="Address" start="35" end="63" type="address" />
-    <group count="2" start="64" size="32">
-      <field name="Immediate Data" start="0" end="31" type="uint" />
-    </group>
+    <field name="Immediate Data" start="64" end="127" type="uint" />
   </instruction>
   <instruction name="MI_LOAD_REGISTER_IMM" bias="2" length="3">
     <field name="DWord Length" start="0" end="7" type="uint" default="1" />
diff --git a/src/intel/genxml/gen75.xml b/src/intel/genxml/gen75.xml
index 3cf3ef9c4afd7..f5747b6b4e2dd 100644
--- a/src/intel/genxml/gen75.xml
+++ b/src/intel/genxml/gen75.xml
@@ -2315,7 +2315,7 @@
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
     <field name="Indirect BSD Data Length" start="32" end="63" type="uint" />
-    <field name="Indirect BSD Data Start Address" start="64" end="92" type="address" />
+    <field name="Indirect BSD Data Start Address" start="64" end="92" type="offset" />
     <field name="Inline Data" start="96" end="191" type="INLINE_DATA_DESCRIPTION_FOR_MFD_AVC_BSD_OBJECT" />
   </instruction>
   <instruction name="MFD_AVC_DPB_STATE" bias="2" length="27" engine="video">
@@ -2381,7 +2381,7 @@
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
     <field name="Indirect BSD Data Length" start="32" end="63" type="uint" />
-    <field name="Indirect BSD Data Start Address" start="64" end="92" type="address" />
+    <field name="Indirect BSD Data Start Address" start="64" end="92" type="offset" />
   </instruction>
   <instruction name="MFD_IT_OBJECT" bias="2" engine="video">
     <field name="DWord Length" start="0" end="11" type="uint" default="6" />
@@ -3494,9 +3494,7 @@
       <value name="GGTT" value="1" />
     </field>
     <field name="Address" start="35" end="63" type="address" />
-    <group count="2" start="64" size="32">
-      <field name="Immediate Data" start="0" end="31" type="uint" />
-    </group>
+    <field name="Immediate Data" start="64" end="127" type="uint" />
   </instruction>
   <instruction name="MI_LOAD_REGISTER_IMM" bias="2" length="3">
     <field name="DWord Length" start="0" end="7" type="uint" default="1" />
diff --git a/src/intel/genxml/gen8.xml b/src/intel/genxml/gen8.xml
index 9f0fa2218b3b4..1f136d15f421b 100644
--- a/src/intel/genxml/gen8.xml
+++ b/src/intel/genxml/gen8.xml
@@ -2524,7 +2524,7 @@
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
     <field name="Indirect BSD Data Length" start="32" end="63" type="uint" />
-    <field name="Indirect BSD Data Start Address" start="64" end="92" type="address" />
+    <field name="Indirect BSD Data Start Address" start="64" end="92" type="offset" />
     <field name="Inline Data" start="96" end="191" type="INLINE_DATA_DESCRIPTION_FOR_MFD_AVC_BSD_OBJECT" />
   </instruction>
   <instruction name="MFD_AVC_DPB_STATE" bias="2" length="27" engine="video">
@@ -2590,7 +2590,7 @@
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
     <field name="Indirect BSD Data Length" start="32" end="63" type="uint" />
-    <field name="Indirect BSD Data Start Address" start="64" end="92" type="address" />
+    <field name="Indirect BSD Data Start Address" start="64" end="92" type="offset" />
   </instruction>
   <instruction name="MFD_IT_OBJECT" bias="2" engine="video">
     <field name="DWord Length" start="0" end="11" type="uint" default="6" />
-- 
GitLab


From b47c5817d8b5a196956f62d112550c27bd83c2e4 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:26:57 +1000
Subject: [PATCH 04/20] hasvk: anv: set Y tiling for video decode images

The video decode hw only works with Y tiled images.
---
 src/intel/vulkan_hasvk/anv_formats.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/intel/vulkan_hasvk/anv_formats.c b/src/intel/vulkan_hasvk/anv_formats.c
index 8c54f7bddc7f5..be4d811cf11c2 100644
--- a/src/intel/vulkan_hasvk/anv_formats.c
+++ b/src/intel/vulkan_hasvk/anv_formats.c
@@ -1008,6 +1008,12 @@ anv_get_image_format_properties(
       isl_mod_info = isl_drm_modifier_get_info(vk_mod_info->drmFormatModifier);
       if (isl_mod_info == NULL)
          goto unsupported;
+
+      /* only allow Y tiling for video decode. */
+      if (info->usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) {
+         if (isl_mod_info->tiling != ISL_TILING_Y0)
+            goto unsupported;
+      }
    }
 
    assert(format->vk_format == info->format);
-- 
GitLab


From 59661098e7e495b3941e3a9a6f9d98724acee372 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:27:37 +1000
Subject: [PATCH 05/20] hasvk: add video format features for the one supported
 video output format

---
 src/intel/vulkan_hasvk/anv_formats.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/intel/vulkan_hasvk/anv_formats.c b/src/intel/vulkan_hasvk/anv_formats.c
index be4d811cf11c2..fe01bedec3916 100644
--- a/src/intel/vulkan_hasvk/anv_formats.c
+++ b/src/intel/vulkan_hasvk/anv_formats.c
@@ -582,6 +582,11 @@ anv_get_image_format_features2(const struct intel_device_info *devinfo,
       return flags;
    }
 
+   if (vk_format == VK_FORMAT_G8_B8R8_2PLANE_420_UNORM) {
+      flags |= VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR |
+               VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR;
+   }
+
    assert(aspects & VK_IMAGE_ASPECT_ANY_COLOR_BIT_ANV);
    const struct anv_format_plane plane_format =
       anv_get_format_plane(devinfo, vk_format, 0, vk_tiling);
-- 
GitLab


From 4ad0e29477fbcaa764101b39180167ca8f374d35 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:28:56 +1000
Subject: [PATCH 06/20] hasvk/format: handle video extensions structs by
 ignoring them

---
 src/intel/vulkan_hasvk/anv_formats.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/intel/vulkan_hasvk/anv_formats.c b/src/intel/vulkan_hasvk/anv_formats.c
index fe01bedec3916..eabe5b7ba1e85 100644
--- a/src/intel/vulkan_hasvk/anv_formats.c
+++ b/src/intel/vulkan_hasvk/anv_formats.c
@@ -977,6 +977,9 @@ void anv_GetPhysicalDeviceFormatProperties2(
          props->bufferFeatures = buffer2;
          break;
       }
+      case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
+         /* don't have any thing to use this for yet */
+         break;
       default:
          anv_debug_ignored_stype(ext->sType);
          break;
@@ -1408,6 +1411,9 @@ VkResult anv_GetPhysicalDeviceImageFormatProperties2(
       case VK_STRUCTURE_TYPE_WSI_IMAGE_CREATE_INFO_MESA:
          from_wsi = true;
          break;
+      case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
+         /* Ignore but don't warn */
+         break;
       default:
          anv_debug_ignored_stype(s->sType);
          break;
-- 
GitLab


From 0669af6a72e67057260e7351cb98071617c0b6df Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:29:58 +1000
Subject: [PATCH 07/20] hasvk/image: allocate some memory for mv storage after
 video images.

these images need motion vector storage allocated with them
---
 src/intel/vulkan_hasvk/anv_image.c   | 33 ++++++++++++++++++++++++++++
 src/intel/vulkan_hasvk/anv_private.h |  5 +++++
 2 files changed, 38 insertions(+)

diff --git a/src/intel/vulkan_hasvk/anv_image.c b/src/intel/vulkan_hasvk/anv_image.c
index d989f96812454..2e0a6a4e162d7 100644
--- a/src/intel/vulkan_hasvk/anv_image.c
+++ b/src/intel/vulkan_hasvk/anv_image.c
@@ -729,6 +729,30 @@ add_shadow_surface(struct anv_device *device,
                       ANV_OFFSET_IMPLICIT);
 }
 
+static VkResult
+add_video_buffers(struct anv_device *device,
+                  struct anv_image *image,
+                  const struct VkVideoProfileListInfoKHR *profile_list)
+{
+   ASSERTED bool ok;
+   unsigned size = 0;
+
+   for (unsigned i = 0; i < profile_list->profileCount; i++) {
+      if (profile_list->pProfiles[i].videoCodecOperation == VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR) {
+         unsigned w_mb = DIV_ROUND_UP(image->vk.extent.width, ANV_MB_WIDTH);
+         unsigned h_mb = DIV_ROUND_UP(image->vk.extent.height, ANV_MB_HEIGHT);
+         size = w_mb * h_mb * 128;
+      }
+   }
+
+   if (size == 0)
+      return VK_SUCCESS;
+
+   ok = image_binding_grow(device, image, ANV_IMAGE_MEMORY_BINDING_PRIVATE,
+                           ANV_OFFSET_IMPLICIT, size, 65536, &image->vid_dmv_top_surface);
+   return ok;
+}
+
 /**
  * Initialize the anv_image::*_surface selected by \a aspect. Then update the
  * image's memory requirements (that is, the image's size and alignment).
@@ -1317,6 +1341,15 @@ anv_image_init(struct anv_device *device, struct anv_image *image,
    if (r != VK_SUCCESS)
       goto fail;
 
+   const VkVideoProfileListInfoKHR *video_profile =
+      vk_find_struct_const(pCreateInfo->pNext,
+                           VIDEO_PROFILE_LIST_INFO_KHR);
+   if (video_profile) {
+      r = add_video_buffers(device, image, video_profile);
+      if (r != VK_SUCCESS)
+         goto fail;
+   }
+
    r = alloc_private_binding(device, image, pCreateInfo);
    if (r != VK_SUCCESS)
       goto fail;
diff --git a/src/intel/vulkan_hasvk/anv_private.h b/src/intel/vulkan_hasvk/anv_private.h
index 05deaa0539cbe..79b40b2324b2e 100644
--- a/src/intel/vulkan_hasvk/anv_private.h
+++ b/src/intel/vulkan_hasvk/anv_private.h
@@ -3321,6 +3321,8 @@ struct anv_image {
        */
       bool can_non_zero_fast_clear;
    } planes[3];
+
+   struct anv_image_memory_range vid_dmv_top_surface;
 };
 
 static inline bool
@@ -3791,6 +3793,9 @@ static inline uint32_t khr_perf_query_preamble_offset(const struct anv_query_poo
    return pool->pass_size * pass + 8;
 }
 
+#define ANV_MB_WIDTH 16
+#define ANV_MB_HEIGHT 16
+
 void
 anv_dump_pipe_bits(enum anv_pipe_bits bits);
 
-- 
GitLab


From d300ebdd384b281d04651b69d13948b810bf35f6 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:31:10 +1000
Subject: [PATCH 08/20] hasvk: add initial video decode support for h264.

This just adds the files with the programming info, it doesn't
enable the extensions etc
---
 src/intel/vulkan_hasvk/anv_private.h |  34 +++
 src/intel/vulkan_hasvk/anv_video.c   | 268 +++++++++++++++++++
 src/intel/vulkan_hasvk/genX_video.c  | 382 +++++++++++++++++++++++++++
 src/intel/vulkan_hasvk/meson.build   |   2 +
 4 files changed, 686 insertions(+)
 create mode 100644 src/intel/vulkan_hasvk/anv_video.c
 create mode 100644 src/intel/vulkan_hasvk/genX_video.c

diff --git a/src/intel/vulkan_hasvk/anv_private.h b/src/intel/vulkan_hasvk/anv_private.h
index 79b40b2324b2e..b83cfa13ed14a 100644
--- a/src/intel/vulkan_hasvk/anv_private.h
+++ b/src/intel/vulkan_hasvk/anv_private.h
@@ -88,6 +88,7 @@
 #include "vk_util.h"
 #include "vk_queue.h"
 #include "vk_log.h"
+#include "vk_video.h"
 
 /* Pre-declarations needed for WSI entrypoints */
 struct wl_surface;
@@ -2654,6 +2655,11 @@ struct anv_cmd_buffer {
     *
     */
    struct u_trace                               trace;
+
+   struct {
+      struct anv_video_session *vid;
+      struct anv_video_session_params *params;
+   } video;
 };
 
 extern const struct vk_command_buffer_ops anv_cmd_buffer_ops;
@@ -3793,9 +3799,35 @@ static inline uint32_t khr_perf_query_preamble_offset(const struct anv_query_poo
    return pool->pass_size * pass + 8;
 }
 
+struct anv_vid_mem {
+   struct anv_device_memory *mem;
+   VkDeviceSize       offset;
+   VkDeviceSize       size;
+};
+
+#define ANV_VIDEO_MEM_REQS_H264 4
 #define ANV_MB_WIDTH 16
 #define ANV_MB_HEIGHT 16
 
+enum {
+   ANV_VID_MEM_H264_INTRA_ROW_STORE,
+   ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE,
+   ANV_VID_MEM_H264_BSD_MPC_ROW_SCRATCH,
+   ANV_VID_MEM_H264_MPR_ROW_SCRATCH,
+   ANV_VID_MEM_H264_MAX,
+};
+
+struct anv_video_session {
+   struct vk_video_session vk;
+
+   /* the decoder needs some private memory allocations */
+   struct anv_vid_mem vid_mem[ANV_VID_MEM_H264_MAX];
+};
+
+struct anv_video_session_params {
+   struct vk_video_session_parameters vk;
+};
+
 void
 anv_dump_pipe_bits(enum anv_pipe_bits bits);
 
@@ -3930,6 +3962,8 @@ VK_DEFINE_NONDISP_HANDLE_CASTS(anv_ycbcr_conversion, base,
 VK_DEFINE_NONDISP_HANDLE_CASTS(anv_performance_configuration_intel, base,
                                VkPerformanceConfigurationINTEL,
                                VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL)
+VK_DEFINE_NONDISP_HANDLE_CASTS(anv_video_session, vk.base, VkVideoSessionKHR, VK_OBJECT_TYPE_VIDEO_SESSION_KHR)
+VK_DEFINE_NONDISP_HANDLE_CASTS(anv_video_session_params, vk.base, VkVideoSessionParametersKHR, VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR)
 
 #define anv_genX(devinfo, thing) ({             \
    __typeof(&gfx7_##thing) genX_thing;          \
diff --git a/src/intel/vulkan_hasvk/anv_video.c b/src/intel/vulkan_hasvk/anv_video.c
new file mode 100644
index 0000000000000..c14d5ec7fd303
--- /dev/null
+++ b/src/intel/vulkan_hasvk/anv_video.c
@@ -0,0 +1,268 @@
+/*
+ * Copyright © 2021 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "anv_private.h"
+
+#include "vk_video/vulkan_video_codecs_common.h"
+
+VkResult
+anv_CreateVideoSessionKHR(VkDevice _device,
+                           const VkVideoSessionCreateInfoKHR *pCreateInfo,
+                           const VkAllocationCallbacks *pAllocator,
+                           VkVideoSessionKHR *pVideoSession)
+{
+   ANV_FROM_HANDLE(anv_device, device, _device);
+
+   struct anv_video_session *vid =
+      vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*vid), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+   if (!vid)
+      return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   memset(vid, 0, sizeof(struct anv_video_session));
+
+   VkResult result = vk_video_session_init(&device->vk,
+                                           &vid->vk,
+                                           pCreateInfo);
+   if (result != VK_SUCCESS) {
+      vk_free2(&device->vk.alloc, pAllocator, vid);
+      return result;
+   }
+
+   *pVideoSession = anv_video_session_to_handle(vid);
+   return VK_SUCCESS;
+}
+
+void
+anv_DestroyVideoSessionKHR(VkDevice _device,
+                           VkVideoSessionKHR _session,
+                           const VkAllocationCallbacks *pAllocator)
+{
+   ANV_FROM_HANDLE(anv_device, device, _device);
+   ANV_FROM_HANDLE(anv_video_session, vid, _session);
+   if (!_session)
+      return;
+
+   vk_object_base_finish(&vid->vk.base);
+   vk_free2(&device->vk.alloc, pAllocator, vid);
+}
+
+VkResult
+anv_CreateVideoSessionParametersKHR(VkDevice _device,
+                                     const VkVideoSessionParametersCreateInfoKHR *pCreateInfo,
+                                     const VkAllocationCallbacks *pAllocator,
+                                     VkVideoSessionParametersKHR *pVideoSessionParameters)
+{
+   ANV_FROM_HANDLE(anv_device, device, _device);
+   ANV_FROM_HANDLE(anv_video_session, vid, pCreateInfo->videoSession);
+   ANV_FROM_HANDLE(anv_video_session_params, templ, pCreateInfo->videoSessionParametersTemplate);
+   struct anv_video_session_params *params =
+      vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*params), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+   if (!params)
+      return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   VkResult result = vk_video_session_parameters_init(&device->vk,
+                                                      &params->vk,
+                                                      &vid->vk,
+                                                      templ ? &templ->vk : NULL,
+                                                      pCreateInfo);
+   if (result != VK_SUCCESS) {
+      vk_free2(&device->vk.alloc, pAllocator, params);
+      return result;
+   }
+
+   *pVideoSessionParameters = anv_video_session_params_to_handle(params);
+   return VK_SUCCESS;
+}
+
+void
+anv_DestroyVideoSessionParametersKHR(VkDevice _device,
+                                      VkVideoSessionParametersKHR _params,
+                                      const VkAllocationCallbacks *pAllocator)
+{
+   ANV_FROM_HANDLE(anv_device, device, _device);
+   ANV_FROM_HANDLE(anv_video_session_params, params, _params);
+   if (!_params)
+      return;
+   vk_video_session_parameters_finish(&device->vk, &params->vk);
+   vk_free2(&device->vk.alloc, pAllocator, params);
+}
+
+VkResult
+anv_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice,
+                                           const VkVideoProfileInfoKHR *pVideoProfile,
+                                           VkVideoCapabilitiesKHR *pCapabilities)
+{
+   pCapabilities->minBitstreamBufferOffsetAlignment = 32;
+   pCapabilities->minBitstreamBufferSizeAlignment = 32;
+   pCapabilities->pictureAccessGranularity.width = ANV_MB_WIDTH;
+   pCapabilities->pictureAccessGranularity.height = ANV_MB_HEIGHT;
+   pCapabilities->minCodedExtent.width = ANV_MB_WIDTH;
+   pCapabilities->minCodedExtent.height = ANV_MB_HEIGHT;
+   pCapabilities->maxCodedExtent.width = 4096;
+   pCapabilities->maxCodedExtent.height = 4096;
+   pCapabilities->flags = VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
+
+   struct VkVideoDecodeCapabilitiesKHR *dec_caps = (struct VkVideoDecodeCapabilitiesKHR *)
+      vk_find_struct(pCapabilities->pNext, VIDEO_DECODE_CAPABILITIES_KHR);
+   if (dec_caps)
+      dec_caps->flags = VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR;
+
+   switch (pVideoProfile->videoCodecOperation) {
+   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
+      struct VkVideoDecodeH264CapabilitiesKHR *ext = (struct VkVideoDecodeH264CapabilitiesKHR *)
+         vk_find_struct(pCapabilities->pNext, VIDEO_DECODE_H264_CAPABILITIES_KHR);
+      pCapabilities->maxDpbSlots = 17;
+      pCapabilities->maxActiveReferencePictures = 16;
+
+      ext->fieldOffsetGranularity.x = 0;
+      ext->fieldOffsetGranularity.y = 0;
+      ext->maxLevelIdc = 51;
+      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME);
+      pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION;
+      break;
+   }
+   default:
+      break;
+   }
+   return VK_SUCCESS;
+}
+
+VkResult
+anv_GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice,
+                                               const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo,
+                                               uint32_t *pVideoFormatPropertyCount,
+                                               VkVideoFormatPropertiesKHR *pVideoFormatProperties)
+{
+   *pVideoFormatPropertyCount = 1;
+
+   if (!pVideoFormatProperties)
+      return VK_SUCCESS;
+
+   pVideoFormatProperties[0].format = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
+   pVideoFormatProperties[0].imageType = VK_IMAGE_TYPE_2D;
+   pVideoFormatProperties[0].imageTiling = VK_IMAGE_TILING_OPTIMAL;
+   pVideoFormatProperties[0].imageUsageFlags = pVideoFormatInfo->imageUsage;
+   return VK_SUCCESS;
+}
+
+static void
+get_h264_video_session_mem_reqs(struct anv_video_session *vid,
+                                VkVideoSessionMemoryRequirementsKHR *mem_reqs,
+                                uint32_t memory_types)
+{
+   uint32_t width_in_mb = align(vid->vk.max_coded.width, ANV_MB_WIDTH) / ANV_MB_WIDTH;
+   /* intra row store is width in macroblocks * 64 */
+   mem_reqs[0].memoryBindIndex = ANV_VID_MEM_H264_INTRA_ROW_STORE;
+   mem_reqs[0].memoryRequirements.size = width_in_mb * 64;
+   mem_reqs[0].memoryRequirements.alignment = 4096;
+   mem_reqs[0].memoryRequirements.memoryTypeBits = memory_types;
+
+   /* deblocking filter row store is width in macroblocks * 64 * 4*/
+   mem_reqs[1].memoryBindIndex = ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE;
+   mem_reqs[1].memoryRequirements.size = width_in_mb * 64 * 4;
+   mem_reqs[1].memoryRequirements.alignment = 4096;
+   mem_reqs[1].memoryRequirements.memoryTypeBits = memory_types;
+
+   /* bsd mpc row scratch is width in macroblocks * 64 * 2 */
+   mem_reqs[2].memoryBindIndex = ANV_VID_MEM_H264_BSD_MPC_ROW_SCRATCH;
+   mem_reqs[2].memoryRequirements.size = width_in_mb * 64 * 2;
+   mem_reqs[2].memoryRequirements.alignment = 4096;
+   mem_reqs[2].memoryRequirements.memoryTypeBits = memory_types;
+
+   /* mpr row scratch is width in macroblocks * 64 * 2 */
+   mem_reqs[3].memoryBindIndex = ANV_VID_MEM_H264_MPR_ROW_SCRATCH;
+   mem_reqs[3].memoryRequirements.size = width_in_mb * 64 * 2;
+   mem_reqs[3].memoryRequirements.alignment = 4096;
+   mem_reqs[3].memoryRequirements.memoryTypeBits = memory_types;
+}
+
+VkResult
+anv_GetVideoSessionMemoryRequirementsKHR(VkDevice _device,
+                                         VkVideoSessionKHR videoSession,
+                                         uint32_t *pVideoSessionMemoryRequirementsCount,
+                                         VkVideoSessionMemoryRequirementsKHR *mem_reqs)
+{
+   ANV_FROM_HANDLE(anv_device, device, _device);
+   ANV_FROM_HANDLE(anv_video_session, vid, videoSession);
+
+   switch (vid->vk.op) {
+   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
+      *pVideoSessionMemoryRequirementsCount = ANV_VIDEO_MEM_REQS_H264;
+      break;
+   default:
+      unreachable("unknown codec");
+   }
+   if (!mem_reqs)
+      return VK_SUCCESS;
+
+   uint32_t memory_types = (1ull << device->physical->memory.type_count) - 1;
+   switch (vid->vk.op) {
+   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
+      get_h264_video_session_mem_reqs(vid, mem_reqs, memory_types);
+      break;
+   default:
+      unreachable("unknown codec");
+   }
+
+   return VK_SUCCESS;
+}
+
+VkResult
+anv_UpdateVideoSessionParametersKHR(VkDevice _device,
+                                     VkVideoSessionParametersKHR _params,
+                                     const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo)
+{
+   ANV_FROM_HANDLE(anv_video_session_params, params, _params);
+   return vk_video_session_parameters_update(&params->vk, pUpdateInfo);
+}
+
+static void
+copy_bind(struct anv_vid_mem *dst,
+          const VkBindVideoSessionMemoryInfoKHR *src)
+{
+   dst->mem = anv_device_memory_from_handle(src->memory);
+   dst->offset = src->memoryOffset;
+   dst->size = src->memorySize;
+}
+
+VkResult
+anv_BindVideoSessionMemoryKHR(VkDevice _device,
+                              VkVideoSessionKHR videoSession,
+                              uint32_t bind_mem_count,
+                              const VkBindVideoSessionMemoryInfoKHR *bind_mem)
+{
+   ANV_FROM_HANDLE(anv_video_session, vid, videoSession);
+
+   assert(bind_mem_count == 4);
+   switch (vid->vk.op) {
+   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
+      for (unsigned i = 0; i < bind_mem_count; i++) {
+         copy_bind(&vid->vid_mem[bind_mem[i].memoryBindIndex], &bind_mem[i]);
+         break;
+      }
+      break;
+   default:
+      unreachable("unknown codec");
+   }
+   return VK_SUCCESS;
+}
diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
new file mode 100644
index 0000000000000..6dfa414feea98
--- /dev/null
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -0,0 +1,382 @@
+/*
+ * Copyright © 2021 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "anv_private.h"
+
+#include "genxml/gen_macros.h"
+#include "genxml/genX_pack.h"
+
+void
+genX(CmdBeginVideoCodingKHR)(VkCommandBuffer commandBuffer,
+                             const VkVideoBeginCodingInfoKHR *pBeginInfo)
+{
+   ANV_FROM_HANDLE(anv_cmd_buffer, cmd_buffer, commandBuffer);
+   ANV_FROM_HANDLE(anv_video_session, vid, pBeginInfo->videoSession);
+   ANV_FROM_HANDLE(anv_video_session_params, params, pBeginInfo->videoSessionParameters);
+
+   cmd_buffer->video.vid = vid;
+   cmd_buffer->video.params = params;
+}
+
+void
+genX(CmdControlVideoCodingKHR)(VkCommandBuffer commandBuffer,
+                               const VkVideoCodingControlInfoKHR *pCodingControlInfo)
+{
+
+}
+
+void
+genX(CmdEndVideoCodingKHR)(VkCommandBuffer commandBuffer,
+                           const VkVideoEndCodingInfoKHR *pEndCodingInfo)
+{
+   ANV_FROM_HANDLE(anv_cmd_buffer, cmd_buffer, commandBuffer);
+
+   cmd_buffer->video.vid = NULL;
+   cmd_buffer->video.params = NULL;
+}
+
+static void
+anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
+                      const VkVideoDecodeInfoKHR *frame_info)
+{
+   ANV_FROM_HANDLE(anv_buffer, src_buffer, frame_info->srcBuffer);
+   struct anv_video_session *vid = cmd_buffer->video.vid;
+   struct anv_video_session_params *params = cmd_buffer->video.params;
+   const struct VkVideoDecodeH264PictureInfoKHR *h264_pic_info =
+      vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_H264_PICTURE_INFO_KHR);
+   const StdVideoH264SequenceParameterSet *sps = vk_video_find_h264_dec_std_sps(&params->vk, h264_pic_info->pStdPictureInfo->seq_parameter_set_id);
+   const StdVideoH264PictureParameterSet *pps = vk_video_find_h264_dec_std_pps(&params->vk, h264_pic_info->pStdPictureInfo->pic_parameter_set_id);
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MI_FLUSH_DW), flush) {
+      flush.DWordLength = 2;
+      flush.VideoPipelineCacheInvalidate = 1;
+   };
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_PIPE_MODE_SELECT), sel) {
+      sel.StandardSelect = SS_AVC;
+      sel.CodecSelect = Decode;
+      sel.DecoderShortFormatMode = ShortFormatDriverInterface;
+      sel.DecoderModeSelect = VLDMode; // Hardcoded
+
+      sel.PreDeblockingOutputEnable = 0;
+      sel.PostDeblockingOutputEnable = 1;
+   }
+
+   const struct anv_image_view *iv = anv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
+   const struct anv_image *img = iv->image;
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_SURFACE_STATE), ss) {
+      ss.Width = img->vk.extent.width - 1;
+      ss.Height = img->vk.extent.height - 1;
+      ss.SurfaceFormat = PLANAR_420_8; // assert on this?
+      ss.InterleaveChroma = 1;
+      ss.SurfacePitch = img->planes[0].primary_surface.isl.row_pitch_B - 1;
+      ss.TiledSurface = img->planes[0].primary_surface.isl.tiling != ISL_TILING_LINEAR;
+      ss.TileWalk = TW_YMAJOR;
+
+      ss.YOffsetforUCb = align(img->vk.extent.height, 32);
+      ss.YOffsetforVCr = align(img->vk.extent.height, 32);
+   }
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_PIPE_BUF_ADDR_STATE), buf) {
+      bool use_pre_deblock = false;
+      if (use_pre_deblock) {
+         buf.PreDeblockingDestinationAddress = anv_image_address(img,
+                                                                 &img->planes[0].primary_surface.memory_range);
+      } else {
+         buf.PostDeblockingDestinationAddress = anv_image_address(img,
+                                                                  &img->planes[0].primary_surface.memory_range);
+      }
+#if GFX_VERx10 >= 75
+      buf.PreDeblockingDestinationMOCS = anv_mocs(cmd_buffer->device, buf.PreDeblockingDestinationAddress.bo, 0);
+      buf.PostDeblockingDestinationMOCS = anv_mocs(cmd_buffer->device, buf.PostDeblockingDestinationAddress.bo, 0);
+      buf.OriginalUncompressedPictureSourceMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+      buf.StreamOutDataDestinationMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+#endif
+
+#if GFX_VER == 8
+      buf.IntraRowStoreScratchBufferAddressHigh = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_INTRA_ROW_STORE].mem->bo,
+         vid->vid_mem[ANV_VID_MEM_H264_INTRA_ROW_STORE].offset };
+      buf.IntraRowStoreScratchBufferMOCS = anv_mocs(cmd_buffer->device, buf.IntraRowStoreScratchBufferAddressHigh.bo, 0);
+      buf.DeblockingFilterRowStoreScratchAddressHigh = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].mem->bo, vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].offset };
+#else
+      buf.IntraRowStoreScratchBufferAddress = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_INTRA_ROW_STORE].mem->bo,
+                                                                     vid->vid_mem[ANV_VID_MEM_H264_INTRA_ROW_STORE].offset };
+#if GFX_VERx10 >= 75
+      buf.IntraRowStoreScratchBufferMOCS = anv_mocs(cmd_buffer->device, vid->vid_mem[ANV_VID_MEM_H264_INTRA_ROW_STORE].mem->bo, 0);
+#endif
+#if GFX_VERx10 == 70
+      buf.DeblockingFilterRowStoreScratchBufferAddress = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].mem->bo, vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].offset };
+#else
+      buf.DeblockingFilterRowStoreScratchAddress = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].mem->bo, vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].offset };
+#endif
+#endif
+#if GFX_VERx10 == 75
+      buf.DeblockingFilterRowStoreScratchMOCS = anv_mocs(cmd_buffer->device, vid->vid_mem[ANV_VID_MEM_H264_DEBLOCK_FILTER_ROW_STORE].mem->bo, 0);
+      buf.MBStatusBufferMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+      buf.MBILDBStreamOutBufferMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+#endif
+
+#if GFX_VERx10 == 80
+      struct anv_bo *ref_bo = NULL;
+#endif
+      for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
+         const struct anv_image_view *ref_iv = anv_image_view_from_handle(frame_info->pReferenceSlots[i].pPictureResource->imageViewBinding);
+         int idx = frame_info->pReferenceSlots[i].slotIndex;
+         buf.ReferencePictureAddress[idx] = anv_image_address(ref_iv->image,
+                                                            &ref_iv->image->planes[0].primary_surface.memory_range);
+#if GFX_VERx10 == 80
+         if (i == 0)
+            ref_bo = ref_iv->image->bindings[0].address.bo;
+#endif
+      }
+#if GFX_VERx10 == 80
+      buf.ReferencePictureMOCS = anv_mocs(cmd_buffer->device, ref_bo, 0);
+#endif
+   }
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_IND_OBJ_BASE_ADDR_STATE), index_obj) {
+      index_obj.MFXIndirectBitstreamObjectAddress = anv_address_add(src_buffer->address,
+                                                                    frame_info->srcBufferOffset);
+#if GFX_VERx10 == 75
+      index_obj.MFXIndirectBitstreamObjectMOCS = anv_mocs(cmd_buffer->device, src_buffer->address.bo,
+                                                          0);
+      index_obj.MFXIndirectMVObjectMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+      index_obj.MFDIndirectITCOEFFObjectMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+      index_obj.MFDIndirectITDBLKObjectMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+      index_obj.MFCIndirectPAKBSEObjectMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+#endif
+#if GFX_VER == 7
+      index_obj.MFXIndirectBitstreamObjectAccessUpperBound = (struct anv_address) { NULL, 0x80000000 };
+#endif
+   }
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_BSP_BUF_BASE_ADDR_STATE), bsp) {
+      bsp.BSDMPCRowStoreScratchBufferAddress = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_BSD_MPC_ROW_SCRATCH].mem->bo,
+         vid->vid_mem[ANV_VID_MEM_H264_BSD_MPC_ROW_SCRATCH].offset };
+#if GFX_VERx10 == 75
+      bsp.BSDMPCRowStoreScratchBufferMOCS = anv_mocs(cmd_buffer->device, vid->vid_mem[ANV_VID_MEM_H264_BSD_MPC_ROW_SCRATCH].mem->bo, 0);
+#endif
+
+      bsp.MPRRowStoreScratchBufferAddress = (struct anv_address) { vid->vid_mem[ANV_VID_MEM_H264_MPR_ROW_SCRATCH].mem->bo,
+         vid->vid_mem[ANV_VID_MEM_H264_BSD_MPC_ROW_SCRATCH].offset };
+
+#if GFX_VERx10 == 75
+      bsp.MPRRowStoreScratchBufferMOCS = anv_mocs(cmd_buffer->device,  vid->vid_mem[ANV_VID_MEM_H264_MPR_ROW_SCRATCH].mem->bo, 0);
+      bsp.BitplaneReadBufferMOCS = anv_mocs(cmd_buffer->device, NULL, 0);
+#endif
+   }
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFD_AVC_DPB_STATE), avc_dpb) {
+      for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
+         const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
+            vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
+         const StdVideoDecodeH264ReferenceInfo *ref_info = dpb_slot->pStdReferenceInfo;
+         int idx = frame_info->pReferenceSlots[i].slotIndex;
+         avc_dpb.NonExistingFrame[idx] = ref_info->flags.is_non_existing;
+         avc_dpb.LongTermFrame[idx] = ref_info->flags.used_for_long_term_reference;
+         if (!ref_info->flags.top_field_flag && !ref_info->flags.bottom_field_flag)
+            avc_dpb.UsedforReference[idx] = 3;
+         else
+            avc_dpb.UsedforReference[idx] = ref_info->flags.top_field_flag | (ref_info->flags.bottom_field_flag << 1);
+         avc_dpb.LTSTFrameNumberList[idx] = ref_info->FrameNum;
+      }
+   }
+
+#if GFX_VERx10 >= 75
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFD_AVC_PICID_STATE), picid) {
+      picid.PictureIDRemappingDisable = false;
+      for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
+         int idx = frame_info->pReferenceSlots[i].slotIndex;
+         picid.PictureID[i] = idx;
+      }
+   }
+#endif
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_AVC_IMG_STATE), avc_img) {
+      avc_img.FrameWidth = sps->pic_width_in_mbs_minus1;
+      avc_img.FrameHeight = sps->pic_height_in_map_units_minus1;
+      avc_img.FrameSize = (sps->pic_width_in_mbs_minus1 + 1) * (sps->pic_height_in_map_units_minus1 + 1);
+
+      if (!h264_pic_info->pStdPictureInfo->flags.field_pic_flag)
+         avc_img.ImageStructure = FramePicture;
+      else if (h264_pic_info->pStdPictureInfo->flags.bottom_field_flag)
+         avc_img.ImageStructure = BottomFieldPicture;
+      else
+         avc_img.ImageStructure = TopFieldPicture;
+
+      avc_img.WeightedBiPredictionIDC = pps->weighted_bipred_idc;
+      avc_img.WeightedPredictionEnable = pps->flags.weighted_pred_flag;
+      avc_img.FirstChromaQPOffset = pps->chroma_qp_index_offset & 0x1f;
+      avc_img.SecondChromaQPOffset = pps->second_chroma_qp_index_offset & 0x1f;
+      avc_img.FieldPicture = h264_pic_info->pStdPictureInfo->flags.field_pic_flag;
+      avc_img.MBAFFMode = (sps->flags.mb_adaptive_frame_field_flag &&
+                           !h264_pic_info->pStdPictureInfo->flags.field_pic_flag);
+      avc_img.FrameMBOnly = sps->flags.frame_mbs_only_flag;
+      avc_img._8x8IDCTTransformMode = pps->flags.transform_8x8_mode_flag;
+      avc_img.Direct8x8Inference = sps->flags.direct_8x8_inference_flag;
+      avc_img.ConstrainedIntraPrediction = pps->flags.constrained_intra_pred_flag;
+      avc_img.NonReferencePicture = !h264_pic_info->pStdPictureInfo->flags.is_reference;
+      avc_img.EntropyCodingSyncEnable = pps->flags.entropy_coding_mode_flag;
+      avc_img.ChromaFormatIDC = sps->chroma_format_idc;
+      avc_img.TrellisQuantizationChromaDisable = true;
+      avc_img.NumberofReferenceFrames = frame_info->referenceSlotCount;
+      avc_img.NumberofActiveReferencePicturesfromL0 = pps->num_ref_idx_l0_default_active_minus1 + 1;
+      avc_img.NumberofActiveReferencePicturesfromL1 = pps->num_ref_idx_l1_default_active_minus1 + 1;
+      avc_img.InitialQPValue = pps->pic_init_qp_minus26;
+      avc_img.PicOrderPresent = pps->flags.bottom_field_pic_order_in_frame_present_flag;
+      avc_img.DeltaPicOrderAlwaysZero = sps->flags.delta_pic_order_always_zero_flag;
+      avc_img.PicOrderCountType = sps->pic_order_cnt_type;
+      avc_img.DeblockingFilterControlPresent = pps->flags.deblocking_filter_control_present_flag;
+      avc_img.RedundantPicCountPresent = pps->flags.redundant_pic_cnt_present_flag;
+      avc_img.Log2MaxFrameNumber = sps->log2_max_frame_num_minus4;
+      avc_img.Log2MaxPicOrderCountLSB = sps->log2_max_pic_order_cnt_lsb_minus4;
+      avc_img.CurrentPictureFrameNumber = h264_pic_info->pStdPictureInfo->frame_num;
+   }
+
+   if (pps->flags.pic_scaling_matrix_present_flag) {
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+         qm.DWordLength = 16;
+         qm.AVC = AVC_4x4_Intra_MATRIX;
+      }
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+         qm.DWordLength = 16;
+         qm.AVC = AVC_4x4_Inter_MATRIX;
+      }
+      if (pps->flags.transform_8x8_mode_flag) {
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+            qm.DWordLength = 16;
+            qm.AVC = AVC_8x8_Intra_MATRIX;
+         }
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+            qm.DWordLength = 16;
+            qm.AVC = AVC_8x8_Inter_MATRIX;
+         }
+      }
+   } else {
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+         qm.DWordLength = 16;
+         qm.AVC = AVC_4x4_Intra_MATRIX;
+         for (unsigned q = 0; q < 3 * 16; q++)
+            qm.ForwardQuantizerMatrix[q] = 0x10;
+      }
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+         qm.DWordLength = 16;
+         qm.AVC = AVC_4x4_Inter_MATRIX;
+         for (unsigned q = 0; q < 3 * 16; q++)
+            qm.ForwardQuantizerMatrix[q] = 0x10;
+      }
+      if (pps->flags.transform_8x8_mode_flag) {
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+            qm.DWordLength = 16;
+            qm.AVC = AVC_8x8_Intra_MATRIX;
+            for (unsigned q = 0; q < 64; q++)
+               qm.ForwardQuantizerMatrix[q] = 0x10;
+         }
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+            qm.DWordLength = 16;
+            qm.AVC = AVC_8x8_Inter_MATRIX;
+            for (unsigned q = 0; q < 64; q++)
+               qm.ForwardQuantizerMatrix[q] = 0x10;
+         }
+      }
+   }
+
+   anv_batch_emit(&cmd_buffer->batch, GENX(MFX_AVC_DIRECTMODE_STATE), avc_directmode) {
+      /* bind reference frame DMV */
+      for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
+         int idx = frame_info->pReferenceSlots[i].slotIndex;
+         const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
+            vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
+         const struct anv_image_view *ref_iv = anv_image_view_from_handle(frame_info->pReferenceSlots[i].pPictureResource->imageViewBinding);
+         const StdVideoDecodeH264ReferenceInfo *ref_info = dpb_slot->pStdReferenceInfo;
+         avc_directmode.DirectMVBufferAddress[idx] = anv_image_address(ref_iv->image,
+                                                                     &ref_iv->image->vid_dmv_top_surface);
+         avc_directmode.POCList[2 * idx] = ref_info->PicOrderCnt[0];
+         avc_directmode.POCList[2 * idx + 1] = ref_info->PicOrderCnt[1];
+      }
+#if GFX_VERx10 == 70
+      avc_directmode.DirectMVBufferWriteAddress[0] = anv_image_address(img,
+                                                                       &img->vid_dmv_top_surface);
+#else
+      avc_directmode.DirectMVBufferWriteAddress = anv_image_address(img,
+                                                                    &img->vid_dmv_top_surface);
+#endif
+      avc_directmode.POCList[32] = h264_pic_info->pStdPictureInfo->PicOrderCnt[0];
+      avc_directmode.POCList[33] = h264_pic_info->pStdPictureInfo->PicOrderCnt[1];
+   }
+
+   uint32_t buffer_offset = frame_info->srcBufferOffset & 4095;
+#define HEADER_OFFSET 3
+   for (unsigned s = 0; s < h264_pic_info->sliceCount; s++) {
+      bool last_slice = s == (h264_pic_info->sliceCount - 1);
+      uint32_t current_offset = h264_pic_info->pSliceOffsets[s];
+      uint32_t this_end;
+      if (!last_slice) {
+         uint32_t next_offset = h264_pic_info->pSliceOffsets[s + 1];
+         uint32_t next_end = h264_pic_info->pSliceOffsets[s + 2];
+         if (s == h264_pic_info->sliceCount - 2)
+            next_end = frame_info->srcBufferRange;
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFD_AVC_SLICEADDR), sliceaddr) {
+            sliceaddr.IndirectBSDDataLength = next_end - next_offset - HEADER_OFFSET;
+            /* start decoding after the 3-byte header. */
+            sliceaddr.IndirectBSDDataStartAddress = buffer_offset + next_offset + HEADER_OFFSET;
+         };
+         this_end = next_offset;
+      } else
+         this_end = frame_info->srcBufferRange;
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFD_AVC_BSD_OBJECT), avc_bsd) {
+         avc_bsd.IndirectBSDDataLength = this_end - current_offset - HEADER_OFFSET;
+         /* start decoding after the 3-byte header. */
+         avc_bsd.IndirectBSDDataStartAddress = buffer_offset + current_offset + HEADER_OFFSET;
+         avc_bsd.InlineData.LastSlice = last_slice;
+         avc_bsd.InlineData.FixPrevMBSkipped = 1;
+#if GFX_VERx10 >= 75
+         avc_bsd.InlineData.IntraPredictionErrorControl = 1;
+         avc_bsd.InlineData.Intra8x84x4PredictionErrorConcealmentControl = 1;
+         avc_bsd.InlineData.ISliceConcealmentMode = 1;
+#endif
+      };
+   }
+}
+
+void
+genX(CmdDecodeVideoKHR)(VkCommandBuffer commandBuffer,
+                        const VkVideoDecodeInfoKHR *frame_info)
+{
+   ANV_FROM_HANDLE(anv_cmd_buffer, cmd_buffer, commandBuffer);
+   switch (cmd_buffer->video.vid->vk.op) {
+   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
+      anv_h264_decode_video(cmd_buffer, frame_info);
+      break;
+   default:
+      assert(0);
+   }
+}
+
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+void
+genX(CmdEncodeVideoKHR)(VkCommandBuffer commandBuffer,
+                        const VkVideoEncodeInfoKHR *pEncodeInfo)
+{
+}
+#endif
diff --git a/src/intel/vulkan_hasvk/meson.build b/src/intel/vulkan_hasvk/meson.build
index 1c44e4723c74e..3a25f41e1e808 100644
--- a/src/intel/vulkan_hasvk/meson.build
+++ b/src/intel/vulkan_hasvk/meson.build
@@ -72,6 +72,7 @@ anv_per_hw_ver_files = files(
   'genX_pipeline.c',
   'genX_query.c',
   'genX_state.c',
+  'genX_video.c',
 )
 foreach g : [['70', ['gfx7_cmd_buffer.c']],
              ['75', ['gfx7_cmd_buffer.c']],
@@ -124,6 +125,7 @@ libanv_files = files(
   'anv_queue.c',
   'anv_util.c',
   'anv_utrace.c',
+  'anv_video.c',
   'anv_wsi.c',
 )
 
-- 
GitLab


From 68945ba7a1b5904e0621aea7fa016856ce92042f Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:32:36 +1000
Subject: [PATCH 09/20] hasvk/query: add query status report

---
 src/intel/vulkan_hasvk/anv_device.c |  7 +++++-
 src/intel/vulkan_hasvk/genX_query.c | 38 +++++++++++++++++++++++++++--
 2 files changed, 42 insertions(+), 3 deletions(-)

diff --git a/src/intel/vulkan_hasvk/anv_device.c b/src/intel/vulkan_hasvk/anv_device.c
index b5b31303495ac..2a1597604af77 100644
--- a/src/intel/vulkan_hasvk/anv_device.c
+++ b/src/intel/vulkan_hasvk/anv_device.c
@@ -2336,7 +2336,12 @@ void anv_GetPhysicalDeviceQueueFamilyProperties2(
                properties->priorityCount = count;
                break;
             }
-
+            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR: {
+               VkQueueFamilyQueryResultStatusPropertiesKHR *prop =
+                  (VkQueueFamilyQueryResultStatusPropertiesKHR *)ext;
+               prop->queryResultStatusSupport = VK_TRUE;
+               break;
+            }
             default:
                anv_debug_ignored_stype(ext->sType);
             }
diff --git a/src/intel/vulkan_hasvk/genX_query.c b/src/intel/vulkan_hasvk/genX_query.c
index b9d99d628b9fa..80b5e8db526d2 100644
--- a/src/intel/vulkan_hasvk/genX_query.c
+++ b/src/intel/vulkan_hasvk/genX_query.c
@@ -59,6 +59,18 @@ anv_query_address(struct anv_query_pool *pool, uint32_t query)
    };
 }
 
+static void
+emit_query_mi_flush_availability(struct anv_cmd_buffer *cmd_buffer,
+                                 struct anv_address addr,
+                                 bool available)
+{
+   anv_batch_emit(&cmd_buffer->batch, GENX(MI_FLUSH_DW), flush) {
+      flush.PostSyncOperation = WriteImmediateData;
+      flush.Address = addr;
+      flush.ImmediateData = available;
+   }
+}
+
 VkResult genX(CreateQueryPool)(
     VkDevice                                    _device,
     const VkQueryPoolCreateInfo*                pCreateInfo,
@@ -163,6 +175,9 @@ VkResult genX(CreateQueryPool)(
       /* Query has two values: begin and end. */
       uint64s_per_slot = 1 + 2;
       break;
+   case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
+      uint64s_per_slot = 1;
+      break;
    default:
       assert(!"Invalid query type");
    }
@@ -453,7 +468,8 @@ VkResult genX(GetQueryPoolResults)(
           pool->type == VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT ||
           pool->type == VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR ||
           pool->type == VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL ||
-          pool->type == VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT);
+          pool->type == VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT ||
+          pool->type == VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR);
 
    if (vk_device_is_lost(&device->vk))
       return VK_ERROR_DEVICE_LOST;
@@ -591,6 +607,14 @@ VkResult genX(GetQueryPoolResults)(
          break;
       }
 
+      case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
+         if (!write_results)
+            break;
+         const uint32_t *query_data = query_slot(pool, firstQuery + i);
+         uint32_t result = available ? *query_data : 0;
+         cpu_write_query_result(pData, flags, idx, result);
+         break;
+
       default:
          unreachable("invalid pool type");
       }
@@ -716,6 +740,11 @@ emit_zero_queries(struct anv_cmd_buffer *cmd_buffer,
       }
       break;
 
+   case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
+      for (uint32_t i = 0; i < num_queries; i++)
+         emit_query_mi_flush_availability(cmd_buffer, anv_query_address(pool, first_index + i), false);
+      break;
+
    default:
       unreachable("Unsupported query type");
    }
@@ -1089,7 +1118,9 @@ void genX(CmdBeginQueryIndexedEXT)(
       emit_perf_intel_query(cmd_buffer, pool, &b, query_addr, false);
       break;
    }
-
+   case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
+      emit_query_mi_flush_availability(cmd_buffer, query_addr, false);
+      break;
    default:
       unreachable("");
    }
@@ -1257,6 +1288,9 @@ void genX(CmdEndQueryIndexedEXT)(
       emit_query_mi_availability(&b, query_addr, true);
       break;
    }
+   case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
+      emit_query_mi_flush_availability(cmd_buffer, query_addr, true);
+      break;
 
    default:
       unreachable("");
-- 
GitLab


From 6423a441408bd9c66c6a15f159c313d2a4946278 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 13:33:01 +1000
Subject: [PATCH 10/20] hasvk: enable video decode extensions

---
 src/intel/vulkan_hasvk/anv_device.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/intel/vulkan_hasvk/anv_device.c b/src/intel/vulkan_hasvk/anv_device.c
index 2a1597604af77..125977291b8c4 100644
--- a/src/intel/vulkan_hasvk/anv_device.c
+++ b/src/intel/vulkan_hasvk/anv_device.c
@@ -253,6 +253,9 @@ get_device_extensions(const struct anv_physical_device *device,
       .KHR_timeline_semaphore                = true,
       .KHR_uniform_buffer_standard_layout    = true,
       .KHR_variable_pointers                 = true,
+      .KHR_video_queue                       = true,
+      .KHR_video_decode_queue                = true,
+      .KHR_video_decode_h264                 = VIDEO_CODEC_H264DEC,
       .KHR_vulkan_memory_model               = true,
       .KHR_workgroup_memory_explicit_layout  = true,
       .KHR_zero_initialize_workgroup_memory  = true,
@@ -2342,6 +2345,13 @@ void anv_GetPhysicalDeviceQueueFamilyProperties2(
                prop->queryResultStatusSupport = VK_TRUE;
                break;
             }
+            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR: {
+               VkQueueFamilyVideoPropertiesKHR *prop =
+                  (VkQueueFamilyVideoPropertiesKHR *)ext;
+               if (queue_family->queueFlags & VK_QUEUE_VIDEO_DECODE_BIT_KHR)
+                  prop->videoCodecOperations = VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR;
+               break;
+            }
             default:
                anv_debug_ignored_stype(ext->sType);
             }
-- 
GitLab


From 162e662ed9c9437b7f63f4bf9cbf19c06a27d9e7 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 14:46:44 +1000
Subject: [PATCH 11/20] hasvk: maybe fix queries

---
 src/intel/vulkan_hasvk/genX_query.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/intel/vulkan_hasvk/genX_query.c b/src/intel/vulkan_hasvk/genX_query.c
index 80b5e8db526d2..15a2d1d7cc75d 100644
--- a/src/intel/vulkan_hasvk/genX_query.c
+++ b/src/intel/vulkan_hasvk/genX_query.c
@@ -821,6 +821,10 @@ void genX(CmdResetQueryPool)(
          emit_query_mi_availability(&b, anv_query_address(pool, firstQuery + i), false);
       break;
    }
+   case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
+      for (uint32_t i = 0; i < queryCount; i++)
+         emit_query_mi_flush_availability(cmd_buffer, anv_query_address(pool, firstQuery + i), false);
+      break;
 
    default:
       unreachable("Unsupported query type");
-- 
GitLab


From 71d025b008b83e1a7333bba222e959414f620c52 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 15:15:57 +1000
Subject: [PATCH 12/20] hasvk: fix broken break

---
 src/intel/vulkan_hasvk/anv_video.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/intel/vulkan_hasvk/anv_video.c b/src/intel/vulkan_hasvk/anv_video.c
index c14d5ec7fd303..38a3b09b2ea24 100644
--- a/src/intel/vulkan_hasvk/anv_video.c
+++ b/src/intel/vulkan_hasvk/anv_video.c
@@ -258,7 +258,6 @@ anv_BindVideoSessionMemoryKHR(VkDevice _device,
    case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
       for (unsigned i = 0; i < bind_mem_count; i++) {
          copy_bind(&vid->vid_mem[bind_mem[i].memoryBindIndex], &bind_mem[i]);
-         break;
       }
       break;
    default:
-- 
GitLab


From c8b996d81a6e8cdf5376cf07b292aca8e9ab3b34 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 15:30:35 +1000
Subject: [PATCH 13/20] intel/gen75: fix some more xml fields

---
 src/intel/genxml/gen75.xml | 11 ++++-------
 1 file changed, 4 insertions(+), 7 deletions(-)

diff --git a/src/intel/genxml/gen75.xml b/src/intel/genxml/gen75.xml
index f5747b6b4e2dd..ba2058896b666 100644
--- a/src/intel/genxml/gen75.xml
+++ b/src/intel/genxml/gen75.xml
@@ -2319,7 +2319,7 @@
     <field name="Inline Data" start="96" end="191" type="INLINE_DATA_DESCRIPTION_FOR_MFD_AVC_BSD_OBJECT" />
   </instruction>
   <instruction name="MFD_AVC_DPB_STATE" bias="2" length="27" engine="video">
-    <field name="DWord Length" start="0" end="11" type="uint" default="9" />
+    <field name="DWord Length" start="0" end="11" type="uint" default="25" />
     <field name="SubOpcode B" start="16" end="20" type="uint" default="6" />
     <field name="SubOpcode A" start="21" end="23" type="uint" default="1" />
     <field name="Media Command Opcode" start="24" end="26" type="uint" default="1" />
@@ -2343,10 +2343,7 @@
       </field>
     </group>
     <group count="16" start="96" size="16">
-      <field name="LTST Frame Number List" start="0" end="15" type="uint" prefix="LTST">
-        <value name="Long Term Frame" value="1" />
-        <value name="Short Term Frame" value="0" />
-      </field>
+      <field name="LTST Frame Number List" start="0" end="15" type="uint" />
     </group>
     <group count="16" start="352" size="16">
       <field name="View ID" start="0" end="15" type="uint" />
@@ -2598,8 +2595,8 @@
       <field name="POC List" start="0" end="31" type="uint" />
     </group>
   </instruction>
-  <instruction name="MFX_AVC_IMG_STATE" bias="2" length="14" engine="video">
-    <field name="DWord Length" start="0" end="11" type="uint" default="12" />
+  <instruction name="MFX_AVC_IMG_STATE" bias="2" length="21" engine="video">
+    <field name="DWord Length" start="0" end="11" type="uint" default="19" />
     <field name="SubOpcode B" start="16" end="20" type="uint" default="0" />
     <field name="SubOpcode A" start="21" end="23" type="uint" default="0" />
     <field name="Media Command Opcode" start="24" end="26" type="uint" default="1" />
-- 
GitLab


From 45ca6212ac844c5f3fe84969a3ff044d4599ea83 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 16:22:36 +1000
Subject: [PATCH 14/20] another query fix

---
 src/intel/vulkan_hasvk/genX_query.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/intel/vulkan_hasvk/genX_query.c b/src/intel/vulkan_hasvk/genX_query.c
index 15a2d1d7cc75d..b6dd7b5b24b74 100644
--- a/src/intel/vulkan_hasvk/genX_query.c
+++ b/src/intel/vulkan_hasvk/genX_query.c
@@ -740,11 +740,6 @@ emit_zero_queries(struct anv_cmd_buffer *cmd_buffer,
       }
       break;
 
-   case VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR:
-      for (uint32_t i = 0; i < num_queries; i++)
-         emit_query_mi_flush_availability(cmd_buffer, anv_query_address(pool, first_index + i), false);
-      break;
-
    default:
       unreachable("Unsupported query type");
    }
-- 
GitLab


From 283fea523ca3ada1626946fd52cf18c7146ef577 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Wed, 8 Feb 2023 16:22:45 +1000
Subject: [PATCH 15/20] add some qm bits

---
 src/intel/vulkan_hasvk/genX_video.c | 39 +++++++++++++++++++++++++++++
 1 file changed, 39 insertions(+)

diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
index 6dfa414feea98..dbbaf384dcdd7 100644
--- a/src/intel/vulkan_hasvk/genX_video.c
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -257,19 +257,58 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
       anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
          qm.DWordLength = 16;
          qm.AVC = AVC_4x4_Intra_MATRIX;
+         for (unsigned m = 0; m < 3; m++)
+            for (unsigned q = 0; q < 16; q++)
+               qm.ForwardQuantizerMatrix[m * 16 + q] = pps->pScalingLists->ScalingList4x4[m][q];
       }
       anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
          qm.DWordLength = 16;
          qm.AVC = AVC_4x4_Inter_MATRIX;
+         for (unsigned m = 0; m < 3; m++)
+            for (unsigned q = 0; q < 16; q++)
+               qm.ForwardQuantizerMatrix[m * 16 + q] = pps->pScalingLists->ScalingList4x4[m + 3][q];
       }
       if (pps->flags.transform_8x8_mode_flag) {
          anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
             qm.DWordLength = 16;
             qm.AVC = AVC_8x8_Intra_MATRIX;
+            for (unsigned q = 0; q < 64; q++)
+               qm.ForwardQuantizerMatrix[q] = pps->pScalingLists->ScalingList8x8[0][q];
+         }
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+            qm.DWordLength = 16;
+            qm.AVC = AVC_8x8_Inter_MATRIX;
+            for (unsigned q = 0; q < 64; q++)
+               qm.ForwardQuantizerMatrix[q] = pps->pScalingLists->ScalingList8x8[3][q];
+         }
+      }
+   } else if (sps->flags.seq_scaling_matrix_present_flag) {
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+         qm.DWordLength = 16;
+         qm.AVC = AVC_4x4_Intra_MATRIX;
+         for (unsigned m = 0; m < 3; m++)
+            for (unsigned q = 0; q < 16; q++)
+               qm.ForwardQuantizerMatrix[m * 16 + q] = sps->pScalingLists->ScalingList4x4[m][q];
+      }
+      anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+         qm.DWordLength = 16;
+         qm.AVC = AVC_4x4_Inter_MATRIX;
+         for (unsigned m = 0; m < 3; m++)
+            for (unsigned q = 0; q < 16; q++)
+               qm.ForwardQuantizerMatrix[m * 16 + q] = sps->pScalingLists->ScalingList4x4[m + 3][q];
+      }
+      if (pps->flags.transform_8x8_mode_flag) {
+         anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
+            qm.DWordLength = 16;
+            qm.AVC = AVC_8x8_Intra_MATRIX;
+            for (unsigned q = 0; q < 64; q++)
+               qm.ForwardQuantizerMatrix[q] = sps->pScalingLists->ScalingList8x8[0][q];
          }
          anv_batch_emit(&cmd_buffer->batch, GENX(MFX_QM_STATE), qm) {
             qm.DWordLength = 16;
             qm.AVC = AVC_8x8_Inter_MATRIX;
+            for (unsigned q = 0; q < 64; q++)
+               qm.ForwardQuantizerMatrix[q] = sps->pScalingLists->ScalingList8x8[3][q];
          }
       }
    } else {
-- 
GitLab


From 1169f128328c35a639546eff9cd6d89d70d3d535 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 14 Mar 2023 16:16:41 +1000
Subject: [PATCH 16/20] fix pic heights

---
 src/intel/vulkan_hasvk/genX_video.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
index dbbaf384dcdd7..6e330b19996fd 100644
--- a/src/intel/vulkan_hasvk/genX_video.c
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -212,10 +212,14 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
    }
 #endif
 
+   uint32_t pic_height = sps->pic_height_in_map_units_minus1 + 1;
+   if (!sps->flags.frame_mbs_only_flag)
+      pic_height *= 2;
+
    anv_batch_emit(&cmd_buffer->batch, GENX(MFX_AVC_IMG_STATE), avc_img) {
       avc_img.FrameWidth = sps->pic_width_in_mbs_minus1;
-      avc_img.FrameHeight = sps->pic_height_in_map_units_minus1;
-      avc_img.FrameSize = (sps->pic_width_in_mbs_minus1 + 1) * (sps->pic_height_in_map_units_minus1 + 1);
+      avc_img.FrameHeight = pic_height - 1;
+      avc_img.FrameSize = (sps->pic_width_in_mbs_minus1 + 1) * pic_height;
 
       if (!h264_pic_info->pStdPictureInfo->flags.field_pic_flag)
          avc_img.ImageStructure = FramePicture;
-- 
GitLab


From ba2e320bb302deb29b074cf009c525736502f5e7 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 14 Mar 2023 16:18:41 +1000
Subject: [PATCH 17/20] fix chroma qp offsets to be ints

---
 src/intel/vulkan_hasvk/genX_video.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
index 6e330b19996fd..5778adfa545de 100644
--- a/src/intel/vulkan_hasvk/genX_video.c
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -230,8 +230,8 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
 
       avc_img.WeightedBiPredictionIDC = pps->weighted_bipred_idc;
       avc_img.WeightedPredictionEnable = pps->flags.weighted_pred_flag;
-      avc_img.FirstChromaQPOffset = pps->chroma_qp_index_offset & 0x1f;
-      avc_img.SecondChromaQPOffset = pps->second_chroma_qp_index_offset & 0x1f;
+      avc_img.FirstChromaQPOffset = pps->chroma_qp_index_offset;
+      avc_img.SecondChromaQPOffset = pps->second_chroma_qp_index_offset;
       avc_img.FieldPicture = h264_pic_info->pStdPictureInfo->flags.field_pic_flag;
       avc_img.MBAFFMode = (sps->flags.mb_adaptive_frame_field_flag &&
                            !h264_pic_info->pStdPictureInfo->flags.field_pic_flag);
-- 
GitLab


From e8ac63099de75aea1c22c796f4e70e13a97c1817 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 14 Mar 2023 16:19:10 +1000
Subject: [PATCH 18/20] disable picture remapping

---
 src/intel/vulkan_hasvk/genX_video.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
index 5778adfa545de..4e0d06ae728ab 100644
--- a/src/intel/vulkan_hasvk/genX_video.c
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -204,11 +204,7 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
 
 #if GFX_VERx10 >= 75
    anv_batch_emit(&cmd_buffer->batch, GENX(MFD_AVC_PICID_STATE), picid) {
-      picid.PictureIDRemappingDisable = false;
-      for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
-         int idx = frame_info->pReferenceSlots[i].slotIndex;
-         picid.PictureID[i] = idx;
-      }
+      picid.PictureIDRemappingDisable = true;
    }
 #endif
 
-- 
GitLab


From 3098576090420c2f689b1207301197b5fce41ae1 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 14 Mar 2023 18:01:01 +1000
Subject: [PATCH 19/20] bunch of wip gfx75 fixes

---
 src/intel/genxml/gen75.xml          | 11 ++++++++---
 src/intel/vulkan_hasvk/genX_video.c | 22 +++++++++++++++++++---
 2 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/src/intel/genxml/gen75.xml b/src/intel/genxml/gen75.xml
index ba2058896b666..e1f9d9ddf808f 100644
--- a/src/intel/genxml/gen75.xml
+++ b/src/intel/genxml/gen75.xml
@@ -2587,10 +2587,15 @@
     <field name="Media Command Opcode" start="24" end="26" type="uint" default="1" />
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
-    <group count="16" start="32" size="64">
-      <field name="Direct MV Buffer - Address" start="0" end="63" type="address" />
+    <field name="Direct MV Buffer - MOCS" start="32" end="35" type="uint" nonzero="true"/>
+    <field name="Direct MV Buffer - Arbitration Priority Control" start="36" end="37" type="uint"/>
+    <field name="Direct MV Buffer 0 - Address" start="38" end="63" type="address"/>
+    <group count="15" start="64" size="64">
+      <field name="Direct MV Buffer - Address 1" start="6" end="31" type="address" />
     </group>
-    <field name="Direct MV Buffer (Write) - Address" start="1088" end="1151" type="address" />
+    <field name="Direct MV Buffer Write - MOCS" start="1088" end="1090" type="uint" nonzero="true"/>
+    <field name="Direct MV Buffer Write - Arbitration Priority Control" start="1091" end="1092" type="uint"/>
+    <field name="Direct MV Buffer (Write) - Address" start="1093" end="1119" type="address" />
     <group count="34" start="1184" size="32">
       <field name="POC List" start="0" end="31" type="uint" />
     </group>
diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
index 4e0d06ae728ab..9a47eb291d390 100644
--- a/src/intel/vulkan_hasvk/genX_video.c
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -156,7 +156,7 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
 
    anv_batch_emit(&cmd_buffer->batch, GENX(MFX_IND_OBJ_BASE_ADDR_STATE), index_obj) {
       index_obj.MFXIndirectBitstreamObjectAddress = anv_address_add(src_buffer->address,
-                                                                    frame_info->srcBufferOffset);
+                                                                    frame_info->srcBufferOffset & ~4095);
 #if GFX_VERx10 == 75
       index_obj.MFXIndirectBitstreamObjectMOCS = anv_mocs(cmd_buffer->device, src_buffer->address.bo,
                                                           0);
@@ -342,14 +342,26 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
 
    anv_batch_emit(&cmd_buffer->batch, GENX(MFX_AVC_DIRECTMODE_STATE), avc_directmode) {
       /* bind reference frame DMV */
+      struct anv_bo *dmv_bo = NULL;
       for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
          int idx = frame_info->pReferenceSlots[i].slotIndex;
          const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
             vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
          const struct anv_image_view *ref_iv = anv_image_view_from_handle(frame_info->pReferenceSlots[i].pPictureResource->imageViewBinding);
          const StdVideoDecodeH264ReferenceInfo *ref_info = dpb_slot->pStdReferenceInfo;
-         avc_directmode.DirectMVBufferAddress[idx] = anv_image_address(ref_iv->image,
-                                                                     &ref_iv->image->vid_dmv_top_surface);
+         if (i == 0) {
+            dmv_bo = anv_image_address(ref_iv->image,
+                                       &ref_iv->image->vid_dmv_top_surface).bo;
+         }
+
+#if GFX_VERx10 == 75
+         if (idx == 0)
+            avc_directmode.DirectMVBuffer0Address = anv_image_address(ref_iv->image,
+                                                                          &ref_iv->image->vid_dmv_top_surface);
+         else
+            avc_directmode.DirectMVBufferAddress1[idx - 1] = anv_image_address(ref_iv->image,
+                                                                          &ref_iv->image->vid_dmv_top_surface);
+#endif
          avc_directmode.POCList[2 * idx] = ref_info->PicOrderCnt[0];
          avc_directmode.POCList[2 * idx + 1] = ref_info->PicOrderCnt[1];
       }
@@ -359,6 +371,10 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
 #else
       avc_directmode.DirectMVBufferWriteAddress = anv_image_address(img,
                                                                     &img->vid_dmv_top_surface);
+#if GFX_VERx10 == 75
+      avc_directmode.DirectMVBufferMOCS = anv_mocs(cmd_buffer->device, dmv_bo, 0);
+      avc_directmode.DirectMVBufferWriteMOCS = anv_mocs(cmd_buffer->device, avc_directmode.DirectMVBufferWriteAddress.bo, 0);
+#endif
 #endif
       avc_directmode.POCList[32] = h264_pic_info->pStdPictureInfo->PicOrderCnt[0];
       avc_directmode.POCList[33] = h264_pic_info->pStdPictureInfo->PicOrderCnt[1];
-- 
GitLab


From f4425f300fa097ceb92d371678c864f09b15f3ad Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@gmail.com>
Date: Wed, 15 Mar 2023 13:49:06 +1000
Subject: [PATCH 20/20] fix gen7 bits

---
 src/intel/genxml/gen7.xml           | 2 +-
 src/intel/vulkan_hasvk/genX_video.c | 8 ++++++++
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/intel/genxml/gen7.xml b/src/intel/genxml/gen7.xml
index e8d4573bc7c71..261190a57c319 100644
--- a/src/intel/genxml/gen7.xml
+++ b/src/intel/genxml/gen7.xml
@@ -2217,7 +2217,7 @@
     <field name="Media Command Opcode" start="24" end="26" type="uint" default="1" />
     <field name="Pipeline" start="27" end="28" type="uint" default="2" />
     <field name="Command Type" start="29" end="31" type="uint" default="3" />
-    <group count="32" start="1056" size="32">
+    <group count="32" start="32" size="32">
       <field name="Direct MV Buffer - Address" start="6" end="31" type="address" />
       <field name="Direct MV Buffer - Arbitration Priority Control" start="4" end="5" type="uint">
         <value name="Highest priority" value="0" />
diff --git a/src/intel/vulkan_hasvk/genX_video.c b/src/intel/vulkan_hasvk/genX_video.c
index 9a47eb291d390..2034ee4727789 100644
--- a/src/intel/vulkan_hasvk/genX_video.c
+++ b/src/intel/vulkan_hasvk/genX_video.c
@@ -353,6 +353,12 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
             dmv_bo = anv_image_address(ref_iv->image,
                                        &ref_iv->image->vid_dmv_top_surface).bo;
          }
+#if GFX_VERx10 == 70
+         avc_directmode.DirectMVBufferAddress[idx * 2] = anv_image_address(ref_iv->image,
+                                                                           &ref_iv->image->vid_dmv_top_surface);
+         avc_directmode.DirectMVBufferAddress[idx * 2 + 1] = anv_image_address(ref_iv->image,
+                                                                           &ref_iv->image->vid_dmv_top_surface);
+#endif
 
 #if GFX_VERx10 == 75
          if (idx == 0)
@@ -368,6 +374,8 @@ anv_h264_decode_video(struct anv_cmd_buffer *cmd_buffer,
 #if GFX_VERx10 == 70
       avc_directmode.DirectMVBufferWriteAddress[0] = anv_image_address(img,
                                                                        &img->vid_dmv_top_surface);
+      avc_directmode.DirectMVBufferWriteAddress[1] = anv_image_address(img,
+                                                                       &img->vid_dmv_top_surface);
 #else
       avc_directmode.DirectMVBufferWriteAddress = anv_image_address(img,
                                                                     &img->vid_dmv_top_surface);
-- 
GitLab

